{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Zvec Ruby","text":"<p>Experimental Project</p> <p>This gem is an experimental collaboration with Claude, exploring what it takes to wrap a C++ vector database for Ruby. It won't replace SQLite3 + sqlite-vec for lightweight use cases, and it certainly won't replace PostgreSQL + pgvector for production workloads. But for a narrow niche \u2014 embedding and searching a small number of short documents without standing up a database server \u2014 it's an interesting option to have in the toolbox.</p> Embedded vector search for Ruby Key Features  - Vector Indexes - HNSW, IVF, and Flat with cosine, L2, and inner-product metrics - Dense &amp; Sparse Vectors - FP16, FP32, FP64, INT4, INT8 support - Scalar Fields - STRING, BOOL, INT32, INT64, FLOAT, DOUBLE, and array variants - Full CRUD - Insert, upsert, update, delete, and fetch by primary key - Filtered Queries - Combine vector similarity with scalar predicates - On-Disk Persistence - Flush and mmap support - Error Hierarchy - Structured exceptions mapping zvec status codes - Native Performance - C++ engine via Rice bindings - Full Documentation Website"},{"location":"#what-is-zvec","title":"What is Zvec?","text":"<p>Zvec is an embedded vector database that stores, indexes, and queries high-dimensional vectors alongside scalar metadata. Unlike client-server databases, zvec runs in-process \u2014 your data lives on disk and loads directly into memory, with no network round-trips. The Ruby gem wraps the C++ library through Rice native bindings.</p>"},{"location":"#when-to-use-zvec","title":"When to Use Zvec","text":"<p>Zvec fits well when you need:</p> <ul> <li>A self-contained vector store with no external dependencies</li> <li>Fast similarity search over a small-to-medium corpus (hundreds to low thousands of documents)</li> <li>An embedded database for CLI tools, scripts, or single-process applications</li> <li>A lightweight alternative to spinning up a database server for prototyping</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require \"zvec\"\nrequire \"tmpdir\"\n\n# Define schema\npk  = Zvec::FieldSchema.create(\"pk\", Zvec::DataType::STRING)\nvec = Zvec::FieldSchema.create(\"embedding\", Zvec::DataType::VECTOR_FP32,\n        dimension: 4,\n        index_params: Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE))\n\nschema = Zvec::CollectionSchema.create(\"demo\", [pk, vec])\n\nDir.mktmpdir(\"zvec\") do |dir|\n  col = Zvec::Collection.create_and_open(File.join(dir, \"demo\"), schema)\n\n  doc = Zvec::Doc.new\n  doc.pk = \"item1\"\n  doc.set_field(\"pk\",        Zvec::DataType::STRING,      \"item1\")\n  doc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, [0.1, 0.2, 0.3, 0.4])\n  col.insert([doc])\n  col.flush\n\n  results = col.query_vector(\"embedding\", [0.1, 0.2, 0.3, 0.4], top_k: 1)\n  puts results.first.to_h(col.schema)\nend\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Head to the Prerequisites page to set up your build environment, then follow the Installation and Quick Start guides.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for every class, method, and constant in the Zvec Ruby gem.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":"Class Description FieldSchema Defines a single field's name, type, dimension, and index CollectionSchema Groups fields into a collection schema Doc Typed key-value container for a single record Collection Persistent on-disk collection with CRUD and query operations"},{"location":"api/#index-and-query-parameters","title":"Index and Query Parameters","text":"Class Description Index Parameters HNSW, IVF, Flat, and Inverted index configuration Query Parameters Search-time tuning for HNSW, IVF, and Flat indexes VectorQuery Full-featured vector query builder CollectionOptions Options for opening collections"},{"location":"api/#status-and-configuration","title":"Status and Configuration","text":"Class Description Status and Errors Status codes and exception hierarchy Global Configuration Memory, threading, and logging settings Enums DataType, IndexType, MetricType, QuantizeType, StatusCode, Operator"},{"location":"api/collection-options/","title":"CollectionOptions","text":"<p><code>Zvec::CollectionOptions</code> controls how a collection is opened.</p>"},{"location":"api/collection-options/#constructor","title":"Constructor","text":"<pre><code>opts = Zvec::CollectionOptions.new\n</code></pre> <p>Creates options with default values.</p>"},{"location":"api/collection-options/#properties","title":"Properties","text":"Method Type Default Description <code>read_only?</code> / <code>read_only=</code> Boolean <code>false</code> Open in read-only mode <code>enable_mmap?</code> / <code>enable_mmap=</code> Boolean <code>false</code> Memory-map data files <code>max_buffer_size</code> / <code>max_buffer_size=</code> Integer (engine default) Write buffer size"},{"location":"api/collection-options/#usage","title":"Usage","text":"<pre><code>opts = Zvec::CollectionOptions.new\nopts.read_only = true\nopts.enable_mmap = true\nopts.max_buffer_size = 4096\n\ncol = Zvec::Collection.open(\"/path/to/collection\", options: opts)\n</code></pre> <p>Or when creating a new collection:</p> <pre><code>col = Zvec::Collection.create_and_open(\"/path/to/collection\", schema, options: opts)\n</code></pre>"},{"location":"api/collection-options/#read-only-mode","title":"Read-Only Mode","text":"<p>When <code>read_only</code> is true, all write operations (<code>insert</code>, <code>upsert</code>, <code>update</code>, <code>delete</code>, <code>flush</code>) raise <code>Zvec::PermissionDeniedError</code>.</p>"},{"location":"api/collection-options/#memory-mapping","title":"Memory Mapping","text":"<p>When <code>enable_mmap</code> is true, data files are memory-mapped instead of loaded into the heap. This can reduce memory usage for large collections at the cost of potentially slower random access.</p>"},{"location":"api/collection-schema/","title":"CollectionSchema","text":"<p><code>Zvec::CollectionSchema</code> groups multiple <code>FieldSchema</code> definitions into a complete schema for a collection.</p>"},{"location":"api/collection-schema/#class-methods","title":"Class Methods","text":""},{"location":"api/collection-schema/#collectionschemacreate","title":"<code>CollectionSchema.create</code>","text":"<pre><code>Zvec::CollectionSchema.create(name, fields)\n</code></pre> Parameter Type Description <code>name</code> String Schema name (typically matches the collection name) <code>fields</code> Array Array of <code>FieldSchema</code> instances <p>Example:</p> <pre><code>schema = Zvec::CollectionSchema.create(\"movies\", [pk, title, year, embedding])\n</code></pre>"},{"location":"api/collection-schema/#collectionschemanew","title":"<code>CollectionSchema.new</code>","text":"<pre><code>Zvec::CollectionSchema.new(name)\n</code></pre> <p>Creates an empty schema. Use <code>add_field</code> to add fields individually.</p>"},{"location":"api/collection-schema/#instance-methods","title":"Instance Methods","text":""},{"location":"api/collection-schema/#properties","title":"Properties","text":"Method Returns Description <code>name</code> String Schema name"},{"location":"api/collection-schema/#field-access","title":"Field Access","text":"Method Returns Description <code>fields</code> Array All field schemas <code>vector_fields</code> Array Only vector field schemas <code>forward_fields</code> Array Non-vector (scalar) field schemas <code>all_field_names</code> Array Field names as strings <code>get_field(name)</code> <code>FieldSchema</code> or <code>nil</code> Look up a field by name <code>has_field?(name)</code> Boolean Check if a field exists"},{"location":"api/collection-schema/#mutation","title":"Mutation","text":"Method Parameters Description <code>add_field(field_schema)</code> <code>FieldSchema</code> Add a field to the schema"},{"location":"api/collection-schema/#display","title":"Display","text":"Method Returns Description <code>to_s</code> String Human-readable schema description"},{"location":"api/collection-schema/#collectionstats","title":"CollectionStats","text":"<p>Returned by <code>Collection#stats</code>:</p> Method Returns Description <code>doc_count</code> Integer Number of documents in the collection <code>index_completeness</code> Hash <code>{ field_name =&gt; completeness_ratio }</code> mapping <code>to_s</code> String Human-readable stats"},{"location":"api/collection/","title":"Collection","text":"<p><code>Zvec::Collection</code> is the primary interface for storing and querying documents. Collections are persistent on-disk databases that hold a schema, vector indexes, and forward storage.</p> <p>Shared Pointer Wrapper</p> <p>Rice wraps <code>shared_ptr&lt;Collection&gt;</code> as <code>Std::SharedPtr&lt;zvec::Collection&gt;</code>. Ruby convenience methods (like <code>query_vector</code>) are mixed into this wrapper class automatically.</p>"},{"location":"api/collection/#class-methods","title":"Class Methods","text":""},{"location":"api/collection/#collectioncreate_and_open","title":"<code>Collection.create_and_open</code>","text":"<pre><code>Zvec::Collection.create_and_open(path, schema, options: nil)\n</code></pre> <p>Create a new collection on disk and return an open handle.</p> Parameter Type Description <code>path</code> String File system path for the collection <code>schema</code> <code>CollectionSchema</code> Schema defining the collection's fields <code>options</code> <code>CollectionOptions</code> Optional open settings <p>Raises <code>Zvec::AlreadyExistsError</code> if the path already exists.</p>"},{"location":"api/collection/#collectionopen","title":"<code>Collection.open</code>","text":"<pre><code>Zvec::Collection.open(path, options: nil)\n</code></pre> <p>Open an existing collection.</p> <p>Raises <code>Zvec::NotFoundError</code> if the path doesn't exist.</p>"},{"location":"api/collection/#instance-methods","title":"Instance Methods","text":""},{"location":"api/collection/#metadata","title":"Metadata","text":"Method Returns Description <code>path</code> String Collection's file system path <code>schema</code> <code>CollectionSchema</code> The collection's schema <code>stats</code> <code>CollectionStats</code> Document count and index completeness <code>options</code> <code>CollectionOptions</code> Current collection options"},{"location":"api/collection/#write-operations","title":"Write Operations","text":""},{"location":"api/collection/#insertdocs","title":"<code>insert(docs)</code>","text":"<pre><code>statuses = col.insert([doc1, doc2, doc3])\n</code></pre> <p>Insert new documents. Returns an array of <code>Status</code> objects.</p>"},{"location":"api/collection/#upsertdocs","title":"<code>upsert(docs)</code>","text":"<pre><code>statuses = col.upsert([doc1, doc2])\n</code></pre> <p>Insert or replace documents by primary key.</p>"},{"location":"api/collection/#updatedocs","title":"<code>update(docs)</code>","text":"<pre><code>statuses = col.update([doc1])\n</code></pre> <p>Update existing documents.</p>"},{"location":"api/collection/#deletepks","title":"<code>delete(pks)</code>","text":"<pre><code>statuses = col.delete([\"pk1\", \"pk2\"])\n</code></pre> <p>Delete documents by primary key. Returns an array of <code>Status</code> objects.</p>"},{"location":"api/collection/#delete_by_filterfilter","title":"<code>delete_by_filter(filter)</code>","text":"<pre><code>col.delete_by_filter(\"year &lt; 2000\")\n</code></pre> <p>Delete all documents matching a filter expression. Raises on error.</p>"},{"location":"api/collection/#read-operations","title":"Read Operations","text":""},{"location":"api/collection/#fetchpks","title":"<code>fetch(pks)</code>","text":"<pre><code>docs = col.fetch([\"pk1\", \"pk2\", \"pk3\"])\n</code></pre> <p>Fetch documents by primary key. Returns a hash <code>{ pk_string =&gt; Doc }</code>. Missing keys are omitted.</p>"},{"location":"api/collection/#queryvector_query","title":"<code>query(vector_query)</code>","text":"<pre><code>results = col.query(vq)\n</code></pre> <p>Execute a <code>VectorQuery</code>. Returns an array of <code>Doc</code> objects sorted by distance.</p>"},{"location":"api/collection/#query_vector-convenience","title":"<code>query_vector</code> (convenience)","text":"<pre><code>results = col.query_vector(field_name, vector, top_k:, filter: nil,\n            include_vector: false, query_params: nil, output_fields: nil)\n</code></pre> <p>Build and execute a <code>VectorQuery</code> in one call. See VectorQuery for parameter details.</p>"},{"location":"api/collection/#group_by_querygroup_query","title":"<code>group_by_query(group_query)</code>","text":"<pre><code>groups = col.group_by_query(gq)\n</code></pre> <p>Execute a <code>GroupByVectorQuery</code>. Returns an array of <code>GroupResult</code> objects.</p>"},{"location":"api/collection/#lifecycle","title":"Lifecycle","text":""},{"location":"api/collection/#flush","title":"<code>flush</code>","text":"<pre><code>col.flush\n</code></pre> <p>Persist buffered writes to disk.</p>"},{"location":"api/collection/#destroy","title":"<code>destroy!</code>","text":"<pre><code>col.destroy!\n</code></pre> <p>Permanently delete the collection and all data from disk.</p>"},{"location":"api/collection/#schema-modification","title":"Schema Modification","text":""},{"location":"api/collection/#add_columnfield_schema-expression-concurrency-0","title":"<code>add_column(field_schema, expression: \"\", concurrency: 0)</code>","text":"<p>Add a new column to the collection.</p>"},{"location":"api/collection/#drop_columnname","title":"<code>drop_column(name)</code>","text":"<p>Remove a column from the collection.</p>"},{"location":"api/collection/#alter_columnname-rename-new_schema-nil-concurrency-0","title":"<code>alter_column(name, rename: \"\", new_schema: nil, concurrency: 0)</code>","text":"<p>Rename or modify a column.</p>"},{"location":"api/collection/#index-management","title":"Index Management","text":""},{"location":"api/collection/#create_indexcolumn-params-concurrency-0","title":"<code>create_index(column, params, concurrency: 0)</code>","text":"<p>Create an index on an existing column.</p>"},{"location":"api/collection/#drop_indexcolumn","title":"<code>drop_index(column)</code>","text":"<p>Remove an index from a column.</p>"},{"location":"api/collection/#optimizeconcurrency-0","title":"<code>optimize(concurrency: 0)</code>","text":"<p>Compact and rebuild indexes.</p>"},{"location":"api/collection/#module-method","title":"Module Method","text":""},{"location":"api/collection/#zvecopen_collection","title":"<code>Zvec.open_collection</code>","text":"<pre><code>Zvec.open_collection(path, options: nil) do |col|\n  # work with col\nend\n# auto-flushed here\n</code></pre> <p>Block-form open that yields the collection and flushes on block exit.</p>"},{"location":"api/doc/","title":"Doc","text":"<p><code>Zvec::Doc</code> is a typed key-value container representing a single document (record) in a collection.</p>"},{"location":"api/doc/#constructor","title":"Constructor","text":"<pre><code>doc = Zvec::Doc.new\n</code></pre> <p>Creates an empty document.</p>"},{"location":"api/doc/#instance-methods","title":"Instance Methods","text":""},{"location":"api/doc/#primary-key-and-metadata","title":"Primary Key and Metadata","text":"Method Returns Description <code>pk</code> String Primary key value <code>pk=</code> \u2014 Set primary key <code>score</code> Float Distance score (populated after queries) <code>score=</code> \u2014 Set score <code>doc_id</code> Integer Internal document ID <code>doc_id=</code> \u2014 Set document ID <code>operator</code> <code>Operator</code> Operation type (INSERT, UPSERT, UPDATE, DELETE) <code>operator=</code> \u2014 Set operator"},{"location":"api/doc/#setting-fields","title":"Setting Fields","text":""},{"location":"api/doc/#set_fieldname-data_type-value","title":"<code>set_field(name, data_type, value)</code>","text":"<p>Set a field value with explicit type dispatch:</p> <pre><code>doc.set_field(\"title\", Zvec::DataType::STRING, \"Example\")\ndoc.set_field(\"year\",  Zvec::DataType::INT32,  2024)\ndoc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, [0.1, 0.2, 0.3])\ndoc.set_field(\"sparse\",    Zvec::DataType::SPARSE_VECTOR_FP32, { 42 =&gt; 0.8 })\ndoc.set_field(\"tags\",      Zvec::DataType::ARRAY_STRING, [\"a\", \"b\"])\ndoc.set_field(\"bio\",       Zvec::DataType::STRING, nil)  # set to null\n</code></pre>"},{"location":"api/doc/#set_field_by_schemaname-field_schema-value","title":"<code>set_field_by_schema(name, field_schema, value)</code>","text":"<p>Set a field using a <code>FieldSchema</code> for type dispatch:</p> <pre><code>fs = schema.get_field(\"title\")\ndoc.set_field_by_schema(\"title\", fs, \"Example\")\n</code></pre>"},{"location":"api/doc/#reading-fields","title":"Reading Fields","text":""},{"location":"api/doc/#get_fieldname-data_type","title":"<code>get_field(name, data_type)</code>","text":"<p>Get a field value with explicit type dispatch. Returns <code>nil</code> if the field is absent or null.</p> <pre><code>title = doc.get_field(\"title\", Zvec::DataType::STRING)\nvec   = doc.get_field(\"embedding\", Zvec::DataType::VECTOR_FP32)\n</code></pre>"},{"location":"api/doc/#conversion","title":"Conversion","text":""},{"location":"api/doc/#to_hschema","title":"<code>to_h(schema)</code>","text":"<p>Convert all fields to a Ruby hash using a <code>CollectionSchema</code> for type dispatch:</p> <pre><code>h = doc.to_h(col.schema)\n# =&gt; {\"pk\"=&gt;\"item1\", \"score\"=&gt;0.123, \"title\"=&gt;\"Example\", \"year\"=&gt;2024, ...}\n</code></pre> <p>The hash always includes <code>pk</code> and <code>score</code> keys.</p>"},{"location":"api/doc/#field-inspection","title":"Field Inspection","text":"Method Returns Description <code>field_names</code> Array Names of all set fields <code>has_field?(name)</code> Boolean Whether the field exists <code>has_value?(name)</code> Boolean Whether the field has a non-null value <code>null?(name)</code> Boolean Whether the field is null <code>empty?</code> Boolean Whether the document has no fields"},{"location":"api/doc/#mutation","title":"Mutation","text":"Method Description <code>remove_field(name)</code> Remove a single field <code>clear</code> Remove all fields"},{"location":"api/doc/#display","title":"Display","text":"Method Returns Description <code>to_s</code> String Debug representation"},{"location":"api/enums/","title":"Enums","text":"<p>All enum constants are defined under the <code>Zvec</code> module.</p>"},{"location":"api/enums/#datatype","title":"DataType","text":"<p>Field data types, accessed as <code>Zvec::DataType::CONSTANT</code>.</p>"},{"location":"api/enums/#scalar-types","title":"Scalar Types","text":"Constant Description <code>UNDEFINED</code> Undefined type <code>BINARY</code> Raw binary data <code>STRING</code> UTF-8 string <code>BOOL</code> Boolean <code>INT32</code> 32-bit signed integer <code>INT64</code> 64-bit signed integer <code>UINT32</code> 32-bit unsigned integer <code>UINT64</code> 64-bit unsigned integer <code>FLOAT</code> 32-bit floating point <code>DOUBLE</code> 64-bit floating point"},{"location":"api/enums/#dense-vector-types","title":"Dense Vector Types","text":"Constant Element Type <code>VECTOR_FP16</code> 16-bit float <code>VECTOR_FP32</code> 32-bit float <code>VECTOR_FP64</code> 64-bit float <code>VECTOR_INT4</code> 4-bit integer (packed as int8) <code>VECTOR_INT8</code> 8-bit integer <code>VECTOR_INT16</code> 16-bit integer <code>VECTOR_BINARY32</code> 32-bit unsigned binary <code>VECTOR_BINARY64</code> 64-bit unsigned binary"},{"location":"api/enums/#sparse-vector-types","title":"Sparse Vector Types","text":"Constant Value Type <code>SPARSE_VECTOR_FP16</code> 16-bit float <code>SPARSE_VECTOR_FP32</code> 32-bit float"},{"location":"api/enums/#array-types","title":"Array Types","text":"Constant Element Type <code>ARRAY_BINARY</code> Binary/String <code>ARRAY_STRING</code> String <code>ARRAY_BOOL</code> Boolean <code>ARRAY_INT32</code> 32-bit integer <code>ARRAY_INT64</code> 64-bit integer <code>ARRAY_UINT32</code> 32-bit unsigned integer <code>ARRAY_UINT64</code> 64-bit unsigned integer <code>ARRAY_FLOAT</code> 32-bit float <code>ARRAY_DOUBLE</code> 64-bit float"},{"location":"api/enums/#indextype","title":"IndexType","text":"<p>Index algorithms, accessed as <code>Zvec::IndexType::CONSTANT</code>.</p> Constant Description <code>UNDEFINED</code> No index <code>HNSW</code> Hierarchical Navigable Small World <code>IVF</code> Inverted File Index <code>FLAT</code> Flat (brute-force) <code>INVERT</code> Inverted index for scalar fields"},{"location":"api/enums/#metrictype","title":"MetricType","text":"<p>Distance metrics, accessed as <code>Zvec::MetricType::CONSTANT</code>.</p> Constant Description <code>UNDEFINED</code> Undefined <code>L2</code> Euclidean (L2) distance <code>IP</code> Inner product <code>COSINE</code> Cosine distance <code>MIPSL2</code> Mixed inner product / L2"},{"location":"api/enums/#quantizetype","title":"QuantizeType","text":"<p>Vector quantization levels, accessed as <code>Zvec::QuantizeType::CONSTANT</code>.</p> Constant Compression Description <code>UNDEFINED</code> None No quantization <code>FP16</code> 2x Float16 quantization <code>INT8</code> 4x 8-bit integer quantization <code>INT4</code> 8x 4-bit integer quantization"},{"location":"api/enums/#statuscode","title":"StatusCode","text":"<p>Operation result codes, accessed as <code>Zvec::StatusCode::CONSTANT</code>.</p> Constant Description <code>OK</code> Success <code>NOT_FOUND</code> Resource not found <code>ALREADY_EXISTS</code> Resource already exists <code>INVALID_ARGUMENT</code> Invalid input <code>PERMISSION_DENIED</code> Insufficient permissions <code>FAILED_PRECONDITION</code> Precondition not met <code>RESOURCE_EXHAUSTED</code> Resources exhausted <code>UNAVAILABLE</code> Temporarily unavailable <code>INTERNAL_ERROR</code> Internal error <code>NOT_SUPPORTED</code> Not supported <code>UNKNOWN</code> Unknown error"},{"location":"api/enums/#operator","title":"Operator","text":"<p>Document operation types, accessed as <code>Zvec::Operator::CONSTANT</code>.</p> Constant Description <code>INSERT</code> Insert new document <code>UPSERT</code> Insert or replace <code>UPDATE</code> Update existing <code>DELETE</code> Delete document"},{"location":"api/enums/#loglevel","title":"LogLevel","text":"<p>Logging severity, accessed as <code>Zvec::LogLevel::CONSTANT</code>.</p> Constant Description <code>DEBUG</code> Verbose diagnostics <code>INFO</code> Operational messages <code>WARN</code> Potential issues <code>ERROR</code> Error conditions <code>FATAL</code> Critical failures"},{"location":"api/field-schema/","title":"FieldSchema","text":"<p><code>Zvec::FieldSchema</code> defines a single field within a collection schema, including its name, data type, vector dimensionality, nullability, and index configuration.</p>"},{"location":"api/field-schema/#class-methods","title":"Class Methods","text":""},{"location":"api/field-schema/#fieldschemacreate","title":"<code>FieldSchema.create</code>","text":"<pre><code>Zvec::FieldSchema.create(name, data_type, dimension: 0, nullable: false, index_params: nil)\n</code></pre> <p>Creates a new field schema.</p> Parameter Type Default Description <code>name</code> String required Field name <code>data_type</code> <code>DataType</code> required Data type constant <code>dimension</code> Integer <code>0</code> Vector dimensionality (required for vector fields) <code>nullable</code> Boolean <code>false</code> Allow nil values <code>index_params</code> <code>IndexParams</code> <code>nil</code> Index configuration <p>Returns a <code>FieldSchema</code> instance (wrapped in a shared pointer).</p> <p>Examples:</p> <pre><code># Scalar field\npk = Zvec::FieldSchema.create(\"pk\", Zvec::DataType::STRING)\n\n# Nullable scalar\nbio = Zvec::FieldSchema.create(\"bio\", Zvec::DataType::STRING, nullable: true)\n\n# Vector field with HNSW index\nembedding = Zvec::FieldSchema.create(\"embedding\", Zvec::DataType::VECTOR_FP32,\n              dimension: 384,\n              index_params: Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE))\n</code></pre>"},{"location":"api/field-schema/#fieldschemanew","title":"<code>FieldSchema.new</code>","text":"<pre><code>Zvec::FieldSchema.new(name, data_type)\n</code></pre> <p>Low-level constructor. Prefer <code>FieldSchema.create</code> which accepts keyword arguments.</p>"},{"location":"api/field-schema/#instance-methods","title":"Instance Methods","text":""},{"location":"api/field-schema/#properties","title":"Properties","text":"Method Returns Description <code>name</code> String Field name <code>data_type</code> <code>DataType</code> Data type enum <code>dimension</code> Integer Vector dimensionality (0 for scalars) <code>nullable?</code> Boolean Whether nil values are allowed <code>index_type</code> <code>IndexType</code> Type of index (HNSW, IVF, FLAT, INVERT, or UNDEFINED) <code>index_params</code> <code>IndexParams</code> Index parameters (nil if no index)"},{"location":"api/field-schema/#setters","title":"Setters","text":"Method Parameter Description <code>dimension=</code> Integer Set vector dimensionality <code>nullable=</code> Boolean Set nullability <code>index_params=</code> <code>IndexParams</code> Set index parameters"},{"location":"api/field-schema/#type-checks","title":"Type Checks","text":"Method Returns Description <code>vector_field?</code> Boolean True for any vector type <code>dense_vector?</code> Boolean True for dense vector types <code>sparse_vector?</code> Boolean True for sparse vector types <code>array_type?</code> Boolean True for array types <code>invert_index?</code> Boolean True if field has an inverted index"},{"location":"api/field-schema/#display","title":"Display","text":"Method Returns Description <code>to_s</code> String Human-readable description"},{"location":"api/global-config/","title":"Global Configuration","text":"<p><code>Zvec.configure</code> sets engine-wide settings for memory, threading, and logging. Call it before creating or opening any collections.</p>"},{"location":"api/global-config/#usage","title":"Usage","text":"<pre><code>Zvec.configure(options_hash)\n</code></pre>"},{"location":"api/global-config/#options","title":"Options","text":"Key Type Description <code>memory_limit_mb</code> Integer Maximum memory usage in megabytes <code>query_thread_count</code> Integer Threads for query execution <code>optimize_thread_count</code> Integer Threads for index optimization <code>invert_to_forward_scan_ratio</code> Float Threshold for inverted-index vs. forward-scan <code>brute_force_by_keys_ratio</code> Float Threshold for brute-force search by keys"},{"location":"api/global-config/#logging-options","title":"Logging Options","text":"Key Type Description <code>log_type</code> String <code>\"console\"</code> (default) or <code>\"file\"</code> <code>log_level</code> <code>LogLevel</code> Minimum severity to log"},{"location":"api/global-config/#file-logging-options","title":"File Logging Options","text":"<p>These apply when <code>log_type: \"file\"</code>:</p> Key Type Default Description <code>log_dir</code> String <code>\"./logs\"</code> Log directory path <code>log_basename</code> String <code>\"zvec.log\"</code> Log file name <code>log_file_size</code> Integer <code>2048</code> Max file size in KB <code>log_overdue_days</code> Integer <code>7</code> Days before rotation"},{"location":"api/global-config/#loglevel-enum","title":"LogLevel Enum","text":"<p>Available as <code>Zvec::LogLevel</code>:</p> Constant Description <code>DEBUG</code> Verbose diagnostics <code>INFO</code> General operational messages <code>WARN</code> Potential issues (default) <code>ERROR</code> Error conditions <code>FATAL</code> Critical failures"},{"location":"api/global-config/#examples","title":"Examples","text":""},{"location":"api/global-config/#minimal","title":"Minimal","text":"<pre><code>Zvec.configure(memory_limit_mb: 256)\n</code></pre>"},{"location":"api/global-config/#full-configuration","title":"Full Configuration","text":"<pre><code>Zvec.configure(\n  memory_limit_mb: 512,\n  query_thread_count: 4,\n  optimize_thread_count: 2,\n  log_type: \"file\",\n  log_level: Zvec::LogLevel::INFO,\n  log_dir: \"/var/log/zvec\",\n  log_basename: \"search.log\",\n  log_file_size: 4096,\n  log_overdue_days: 14\n)\n</code></pre>"},{"location":"api/index-params/","title":"Index Parameters","text":"<p>Index parameters control how vector and scalar indexes are built. All parameter classes inherit from <code>Zvec::IndexParams</code>.</p>"},{"location":"api/index-params/#inheritance-hierarchy","title":"Inheritance Hierarchy","text":"<pre><code>IndexParams (abstract)\n  \u251c\u2500\u2500 VectorIndexParams (abstract)\n  \u2502     \u251c\u2500\u2500 HnswIndexParams\n  \u2502     \u251c\u2500\u2500 FlatIndexParams\n  \u2502     \u2514\u2500\u2500 IVFIndexParams\n  \u2514\u2500\u2500 InvertIndexParams\n</code></pre>"},{"location":"api/index-params/#indexparams-base","title":"IndexParams (Base)","text":"<p>All index params share these methods:</p> Method Returns Description <code>type</code> <code>IndexType</code> HNSW, IVF, FLAT, or INVERT <code>vector_index_type?</code> Boolean True for vector index types <code>to_s</code> String Human-readable description"},{"location":"api/index-params/#vectorindexparams-base","title":"VectorIndexParams (Base)","text":"<p>Shared by all vector index types:</p> Method Returns Description <code>metric_type</code> <code>MetricType</code> Distance metric (COSINE, L2, IP) <code>metric_type=</code> \u2014 Set distance metric <code>quantize_type</code> <code>QuantizeType</code> Quantization (FP16, INT8, INT4, or UNDEFINED) <code>quantize_type=</code> \u2014 Set quantization"},{"location":"api/index-params/#hnswindexparams","title":"HnswIndexParams","text":"<pre><code>params = Zvec::HnswIndexParams.new(metric_type, m: 50, ef_construction: 500,\n           quantize_type: Zvec::QuantizeType::UNDEFINED)\n</code></pre> Parameter Type Default Description <code>metric_type</code> <code>MetricType</code> required Distance metric <code>m</code> Integer <code>50</code> Max connections per node <code>ef_construction</code> Integer <code>500</code> Search width during index build <code>quantize_type</code> <code>QuantizeType</code> <code>UNDEFINED</code> Optional quantization <p>Instance methods:</p> Method Returns Description <code>m</code> Integer Max connections <code>m=</code> \u2014 Set max connections <code>ef_construction</code> Integer Construction search width <code>ef_construction=</code> \u2014 Set construction search width"},{"location":"api/index-params/#flatindexparams","title":"FlatIndexParams","text":"<pre><code>params = Zvec::FlatIndexParams.new(metric_type, quantize_type: Zvec::QuantizeType::UNDEFINED)\n</code></pre> Parameter Type Default Description <code>metric_type</code> <code>MetricType</code> required Distance metric <code>quantize_type</code> <code>QuantizeType</code> <code>UNDEFINED</code> Optional quantization <p>No additional instance methods beyond <code>VectorIndexParams</code>.</p>"},{"location":"api/index-params/#ivfindexparams","title":"IVFIndexParams","text":"<pre><code>params = Zvec::IVFIndexParams.new(metric_type, n_list: 1024, n_iters: 10,\n           use_soar: false, quantize_type: Zvec::QuantizeType::UNDEFINED)\n</code></pre> Parameter Type Default Description <code>metric_type</code> <code>MetricType</code> required Distance metric <code>n_list</code> Integer <code>1024</code> Number of clusters <code>n_iters</code> Integer <code>10</code> K-means iterations <code>use_soar</code> Boolean <code>false</code> Enable SOAR optimization <code>quantize_type</code> <code>QuantizeType</code> <code>UNDEFINED</code> Optional quantization <p>Instance methods:</p> Method Returns Description <code>n_list</code> Integer Number of clusters <code>n_list=</code> \u2014 Set cluster count <code>n_iters</code> Integer K-means iterations <code>n_iters=</code> \u2014 Set iteration count <code>use_soar?</code> Boolean SOAR optimization enabled <code>use_soar=</code> \u2014 Set SOAR optimization"},{"location":"api/index-params/#invertindexparams","title":"InvertIndexParams","text":"<p>For scalar field indexes used in filtered queries:</p> <pre><code>params = Zvec::InvertIndexParams.new(\n           enable_range_optimization: true,\n           enable_extended_wildcard: false)\n</code></pre> Parameter Type Default Description <code>enable_range_optimization</code> Boolean <code>true</code> Optimize range queries <code>enable_extended_wildcard</code> Boolean <code>false</code> Extended wildcard support <p>Instance methods:</p> Method Returns Description <code>enable_range_optimization?</code> Boolean Range optimization enabled <code>enable_range_optimization=</code> \u2014 Set range optimization <code>enable_extended_wildcard?</code> Boolean Extended wildcards enabled <code>enable_extended_wildcard=</code> \u2014 Set extended wildcards"},{"location":"api/query-params/","title":"Query Parameters","text":"<p>Query parameters control search-time behavior for vector queries. Each index type has its own query parameter class.</p>"},{"location":"api/query-params/#inheritance-hierarchy","title":"Inheritance Hierarchy","text":"<pre><code>QueryParams (abstract)\n  \u251c\u2500\u2500 HnswQueryParams\n  \u251c\u2500\u2500 IVFQueryParams\n  \u2514\u2500\u2500 FlatQueryParams\n</code></pre>"},{"location":"api/query-params/#queryparams-base","title":"QueryParams (Base)","text":"<p>Shared by all query parameter types:</p> Method Returns Description <code>type</code> <code>IndexType</code> Index type this applies to <code>radius</code> Float Max distance threshold <code>radius=</code> \u2014 Set max distance threshold <code>linear?</code> Boolean Force linear (brute-force) scan <code>linear=</code> \u2014 Set linear scan mode <code>using_refiner?</code> Boolean Re-rank with exact distances <code>using_refiner=</code> \u2014 Set refiner mode"},{"location":"api/query-params/#hnswqueryparams","title":"HnswQueryParams","text":"<pre><code>qp = Zvec::HnswQueryParams.new(ef: 300, radius: 0.0, is_linear: false, is_using_refiner: false)\n</code></pre> Parameter Type Default Description <code>ef</code> Integer <code>300</code> Search width at query time <code>radius</code> Float <code>0.0</code> Max distance (0 = unlimited) <code>is_linear</code> Boolean <code>false</code> Bypass HNSW, use brute force <code>is_using_refiner</code> Boolean <code>false</code> Re-rank candidates exactly <p>Instance methods:</p> Method Returns Description <code>ef</code> Integer Search width <code>ef=</code> \u2014 Set search width"},{"location":"api/query-params/#ivfqueryparams","title":"IVFQueryParams","text":"<pre><code>qp = Zvec::IVFQueryParams.new(nprobe: 10, is_using_refiner: false, scale_factor: 10.0)\n</code></pre> Parameter Type Default Description <code>nprobe</code> Integer <code>10</code> Number of clusters to search <code>is_using_refiner</code> Boolean <code>false</code> Re-rank candidates exactly <code>scale_factor</code> Float <code>10.0</code> Internal scaling parameter <p>Instance methods:</p> Method Returns Description <code>nprobe</code> Integer Clusters to search <code>nprobe=</code> \u2014 Set probe count <code>scale_factor</code> Float Scale factor <code>scale_factor=</code> \u2014 Set scale factor"},{"location":"api/query-params/#flatqueryparams","title":"FlatQueryParams","text":"<pre><code>qp = Zvec::FlatQueryParams.new(is_using_refiner: false, scale_factor: 10.0)\n</code></pre> Parameter Type Default Description <code>is_using_refiner</code> Boolean <code>false</code> Re-rank candidates <code>scale_factor</code> Float <code>10.0</code> Internal scaling parameter <p>Instance methods:</p> Method Returns Description <code>scale_factor</code> Float Scale factor <code>scale_factor=</code> \u2014 Set scale factor"},{"location":"api/query-params/#usage-with-query_vector","title":"Usage with query_vector","text":"<p>Pass query params as the <code>query_params</code> keyword argument:</p> <pre><code>qp = Zvec::HnswQueryParams.new(ef: 500)\nresults = col.query_vector(\"embedding\", query_vec, top_k: 10, query_params: qp)\n</code></pre>"},{"location":"api/status-and-errors/","title":"Status and Errors","text":""},{"location":"api/status-and-errors/#status","title":"Status","text":"<p><code>Zvec::Status</code> wraps C++ status codes returned by batch operations (insert, upsert, update, delete).</p>"},{"location":"api/status-and-errors/#methods","title":"Methods","text":"Method Returns Description <code>ok?</code> Boolean True if the operation succeeded <code>code</code> <code>StatusCode</code> Status code enum value <code>message</code> String Human-readable error message <code>to_s</code> String <code>\"OK\"</code> or <code>\"Error(code): message\"</code>"},{"location":"api/status-and-errors/#usage","title":"Usage","text":"<pre><code>statuses = col.insert([doc1, doc2])\nstatuses.each do |s|\n  if s.ok?\n    puts \"Success\"\n  else\n    puts \"Failed: #{s.message}\"\n  end\nend\n</code></pre>"},{"location":"api/status-and-errors/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>Operations that fail fatally (like opening a nonexistent collection) raise exceptions instead of returning status objects. All zvec exceptions inherit from <code>Zvec::Error</code>:</p> <pre><code>StandardError\n  \u2514\u2500\u2500 Zvec::Error\n        \u251c\u2500\u2500 Zvec::NotFoundError\n        \u251c\u2500\u2500 Zvec::AlreadyExistsError\n        \u251c\u2500\u2500 Zvec::InvalidArgumentError\n        \u251c\u2500\u2500 Zvec::PermissionDeniedError\n        \u251c\u2500\u2500 Zvec::FailedPreconditionError\n        \u251c\u2500\u2500 Zvec::ResourceExhaustedError\n        \u251c\u2500\u2500 Zvec::UnavailableError\n        \u251c\u2500\u2500 Zvec::InternalError\n        \u2514\u2500\u2500 Zvec::NotSupportedError\n</code></pre>"},{"location":"api/status-and-errors/#exception-reference","title":"Exception Reference","text":"Exception StatusCode Typical Cause <code>Zvec::Error</code> (any) Base class for all zvec errors <code>NotFoundError</code> <code>NOT_FOUND</code> Collection path doesn't exist <code>AlreadyExistsError</code> <code>ALREADY_EXISTS</code> Collection already exists at path <code>InvalidArgumentError</code> <code>INVALID_ARGUMENT</code> Wrong data type, bad filter, dimension mismatch <code>PermissionDeniedError</code> <code>PERMISSION_DENIED</code> Writing to read-only collection <code>FailedPreconditionError</code> <code>FAILED_PRECONDITION</code> Required precondition not met <code>ResourceExhaustedError</code> <code>RESOURCE_EXHAUSTED</code> Memory limit exceeded <code>UnavailableError</code> <code>UNAVAILABLE</code> Resource temporarily unavailable <code>InternalError</code> <code>INTERNAL_ERROR</code> Unexpected engine failure <code>NotSupportedError</code> <code>NOT_SUPPORTED</code> Feature not available"},{"location":"api/status-and-errors/#statuscode-enum","title":"StatusCode Enum","text":"<p>Available as <code>Zvec::StatusCode</code>:</p> Constant Description <code>OK</code> Success <code>NOT_FOUND</code> Resource not found <code>ALREADY_EXISTS</code> Resource already exists <code>INVALID_ARGUMENT</code> Invalid input <code>PERMISSION_DENIED</code> Insufficient permissions <code>FAILED_PRECONDITION</code> Precondition failed <code>RESOURCE_EXHAUSTED</code> Resources exhausted <code>UNAVAILABLE</code> Temporarily unavailable <code>INTERNAL_ERROR</code> Internal error <code>NOT_SUPPORTED</code> Not supported <code>UNKNOWN</code> Unknown error"},{"location":"api/vector-query/","title":"VectorQuery","text":"<p><code>Zvec::VectorQuery</code> provides full control over vector similarity searches. For simple queries, prefer the <code>query_vector</code> convenience method on <code>Collection</code>.</p>"},{"location":"api/vector-query/#constructor","title":"Constructor","text":"<pre><code>vq = Zvec::VectorQuery.new\n</code></pre>"},{"location":"api/vector-query/#properties","title":"Properties","text":"Method Type Description <code>topk</code> / <code>topk=</code> Integer Number of results to return <code>field_name</code> / <code>field_name=</code> String Vector field to search <code>filter</code> / <code>filter=</code> String Scalar filter expression <code>include_vector?</code> / <code>include_vector=</code> Boolean Include vector data in results <code>include_doc_id?</code> / <code>include_doc_id=</code> Boolean Include internal doc IDs <code>query_params</code> / <code>query_params=</code> <code>QueryParams</code> Index-specific search parameters <code>output_fields=</code> Array Field names to include in results"},{"location":"api/vector-query/#setting-the-query-vector","title":"Setting the Query Vector","text":""},{"location":"api/vector-query/#set_vectorfield_schema-data","title":"<code>set_vector(field_schema, data)</code>","text":"<p>Set the query vector using a <code>FieldSchema</code> for type dispatch:</p> <pre><code>field_schema = col.schema.get_field(\"embedding\")\n\n# Dense vector \u2014 pass a Ruby Array\nvq.set_vector(field_schema, [0.1, 0.2, 0.3, 0.4])\n\n# Sparse vector \u2014 pass a Ruby Hash\nvq.set_vector(field_schema, { 42 =&gt; 0.8, 99 =&gt; 0.3 })\n</code></pre> <p>The method automatically handles dense vs. sparse serialization based on the field schema's data type.</p>"},{"location":"api/vector-query/#complete-example","title":"Complete Example","text":"<pre><code>vq = Zvec::VectorQuery.new\nvq.topk = 10\nvq.field_name = \"embedding\"\nvq.filter = \"year &gt; 2020 AND category = 'science'\"\nvq.include_vector = false\nvq.query_params = Zvec::HnswQueryParams.new(ef: 500)\nvq.output_fields = [\"title\", \"year\", \"category\"]\n\nfield_schema = col.schema.get_field(\"embedding\")\nvq.set_vector(field_schema, query_vec)\n\nresults = col.query(vq)\nresults.each do |doc|\n  h = doc.to_h(col.schema)\n  puts \"#{h['title']} \u2014 distance: #{h['score'].round(4)}\"\nend\n</code></pre>"},{"location":"api/vector-query/#groupbyvectorquery","title":"GroupByVectorQuery","text":"<p>Group results by a scalar field value:</p> <pre><code>gq = Zvec::GroupByVectorQuery.new\n</code></pre>"},{"location":"api/vector-query/#properties_1","title":"Properties","text":"Method Type Description <code>field_name</code> / <code>field_name=</code> String Vector field to search <code>filter</code> / <code>filter=</code> String Scalar filter expression <code>include_vector?</code> / <code>include_vector=</code> Boolean Include vector data <code>group_by_field_name</code> / <code>group_by_field_name=</code> String Field to group by <code>group_count</code> / <code>group_count=</code> Integer Number of groups <code>group_topk</code> / <code>group_topk=</code> Integer Results per group <code>query_params</code> / <code>query_params=</code> <code>QueryParams</code> Search parameters <code>set_vector(field_schema, data)</code> \u2014 Set the query vector"},{"location":"api/vector-query/#groupresult","title":"GroupResult","text":"<p>Each group in the results contains:</p> Method Returns Description <code>group_by_value</code> String The group key value <code>docs</code> Array Array of <code>Doc</code> objects in this group"},{"location":"architecture/","title":"Architecture","text":"<p>This section covers the internal design of the zvec Ruby gem.</p> <ul> <li>Build System \u2014 How the CMake build works, presets, and dependencies.</li> <li>Native Extension \u2014 The C++ binding layer: Rice, file organization, and the shared-pointer pattern.</li> </ul>"},{"location":"architecture/build-system/","title":"Build System","text":"<p>The zvec gem uses CMake to build the native extension, rather than the traditional Ruby <code>extconf.rb</code> + <code>mkmf</code> approach. This is necessary because the zvec C++ library has its own CMake build with many dependencies.</p>"},{"location":"architecture/build-system/#why-cmake","title":"Why CMake?","text":"<p>The zvec C++ library uses CMake with subdirectory builds for its dependencies (HNSW algorithms, quantizers, parsers, etc.). Wrapping this in <code>extconf.rb</code> would require duplicating the entire build configuration. Instead, the gem's <code>CMakeLists.txt</code> adds zvec as a CMake subdirectory and links against it.</p>"},{"location":"architecture/build-system/#build-flow","title":"Build Flow","text":"<pre><code>graph TD\n    A[ext/CMakeLists.txt] --&gt; B[FetchContent: Rice v4.11]\n    A --&gt; C[add_subdirectory: vendor/zvec]\n    C --&gt; D[zvec builds its dependencies]\n    D --&gt; E[antlr4, Arrow, HNSW, IVF, ...]\n    B --&gt; F[zvec_ext.bundle]\n    C --&gt; F\n    F --&gt; G[lib/zvec_ext.bundle]</code></pre>"},{"location":"architecture/build-system/#directory-layout","title":"Directory Layout","text":"<pre><code>ext/\n  CMakeLists.txt       # Main build file\n  CMakePresets.json     # Build presets (debug/release)\n  cmake/               # CMake helper modules\n  zvec/\n    zvec_ext.cpp        # Extension entry point\n    zvec_common.hpp     # Shared includes and error handling\n    zvec_types.cpp      # Enum bindings\n    zvec_status.cpp     # Status and exception hierarchy\n    zvec_params.cpp     # Index/query parameter bindings\n    zvec_schema.cpp     # FieldSchema and CollectionSchema\n    zvec_doc.cpp        # Doc with typed get/set\n    zvec_collection.cpp # Collection CRUD operations\n    zvec_config.cpp     # Global configuration\n</code></pre>"},{"location":"architecture/build-system/#build-presets","title":"Build Presets","text":"<p>Defined in <code>ext/CMakePresets.json</code>:</p> Preset Build Type Flags Use Case <code>macos-debug</code> Debug <code>-g -O0</code> Development, lldb debugging <code>macos-release</code> Release <code>-O3 -DNDEBUG</code> Performance, distribution <p>Both presets use the Ninja generator and set <code>CMAKE_PREFIX_PATH</code> to <code>/opt/homebrew/opt/icu4c@78</code>.</p>"},{"location":"architecture/build-system/#dependencies","title":"Dependencies","text":"<p>The build pulls in these dependencies automatically:</p> Dependency Method Purpose Rice v4.11 CMake FetchContent C++/Ruby binding layer zvec C++ Git submodule (<code>vendor/zvec</code>) Vector database engine ICU4C System (Homebrew) Unicode support <p>Rice is header-only, so no separate library is built \u2014 it's compiled directly into the extension.</p>"},{"location":"architecture/build-system/#force-loading-algorithm-libraries","title":"Force-Loading Algorithm Libraries","text":"<p>zvec uses self-registering algorithm factories. On macOS, these static libraries must be force-loaded to ensure their registration code runs:</p> <pre><code>foreach(lib ${ZVEC_ALGO_LIBS})\n  target_link_libraries(zvec_ext PRIVATE -Wl,-force_load,$&lt;TARGET_FILE:${lib}&gt;)\nendforeach()\n</code></pre> <p>Without <code>-force_load</code>, the linker would strip the \"unused\" registration code and the algorithms would silently fail to register.</p>"},{"location":"architecture/build-system/#output","title":"Output","text":"<p>The build outputs <code>zvec_ext.bundle</code> directly to the <code>lib/</code> directory:</p> <pre><code>set_target_properties(zvec_ext PROPERTIES\n  PREFIX \"\"\n  SUFFIX \".bundle\"\n  LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/../lib\"\n)\n</code></pre> <p>Ruby loads it via <code>require \"zvec_ext\"</code> in <code>lib/zvec.rb</code>.</p>"},{"location":"architecture/native-extension/","title":"Native Extension","text":"<p>The native extension bridges zvec's C++ API to Ruby using Rice v4.11.</p>"},{"location":"architecture/native-extension/#file-organization","title":"File Organization","text":"<p>Binding files are split by zvec domain. They are initialized in dependency order from <code>zvec_ext.cpp</code>:</p> File Purpose Dependencies <code>zvec_types.cpp</code> Enum constants (DataType, MetricType, etc.) None <code>zvec_status.cpp</code> Status class and exception hierarchy Types <code>zvec_params.cpp</code> Index params, query params, CollectionOptions, VectorQuery Types <code>zvec_schema.cpp</code> FieldSchema, CollectionSchema, CollectionStats Params <code>zvec_doc.cpp</code> Doc with typed field get/set Schema, Types <code>zvec_collection.cpp</code> Collection CRUD and query operations All above <code>zvec_config.cpp</code> Global configuration Status"},{"location":"architecture/native-extension/#error-handling-pattern","title":"Error Handling Pattern","text":"<p><code>zvec_common.hpp</code> defines two error-handling helpers used throughout the bindings:</p>"},{"location":"architecture/native-extension/#throw_if_errorstatus","title":"<code>throw_if_error(status)</code>","text":"<p>Converts a C++ <code>Status</code> to the appropriate Ruby exception:</p> <pre><code>void throw_if_error(const zvec::Status&amp; status) {\n  if (status.ok()) return;\n  // maps StatusCode to Zvec::*Error and calls rb_raise\n}\n</code></pre>"},{"location":"architecture/native-extension/#unwrap_resultexpected","title":"<code>unwrap_result(expected)</code>","text":"<p>Unwraps a <code>tl::expected&lt;T, Status&gt;</code>, returning the value on success or raising on error:</p> <pre><code>template &lt;typename T&gt;\nT unwrap_result(const tl::expected&lt;T, zvec::Status&gt;&amp; result) {\n  if (result.has_value()) return result.value();\n  throw_if_error(result.error());\n}\n</code></pre>"},{"location":"architecture/native-extension/#the-sharedptr-pattern","title":"The SharedPtr Pattern","text":"<p>Rice wraps <code>shared_ptr&lt;Collection&gt;</code> as <code>Std::SharedPtr&lt;zvec::Collection&gt;</code>, a proxy class that delegates method calls to the underlying C++ object via <code>method_missing</code>.</p> <p>Ruby convenience methods (like <code>query_vector</code>) cannot be defined on <code>Zvec::Collection</code> directly because Rice's proxy class isn't the same as <code>Zvec::Collection</code>. Instead, <code>lib/zvec.rb</code> uses <code>ObjectSpace</code> to discover the proxy class at load time and mix in the <code>CollectionConvenience</code> module:</p> <pre><code>ObjectSpace.each_object(Class) do |klass|\n  if klass.name&amp;.start_with?(\"Std::SharedPtr\") &amp;&amp; klass.name&amp;.include?(\"Collection\")\n    klass.include(Zvec::CollectionConvenience)\n  end\nend\n</code></pre> <p>This is the key architectural detail that enables the <code>query_vector</code> helper and the <code>to_h</code> doc conversion to work naturally.</p>"},{"location":"architecture/native-extension/#type-dispatch-in-doc","title":"Type Dispatch in Doc","text":"<p><code>zvec_doc.cpp</code> implements <code>doc_set_field</code> and <code>doc_get_field</code> as large <code>switch</code> statements over <code>DataType</code>. This is necessary because C++ templates can't be dispatched at runtime \u2014 each type requires explicit instantiation:</p> <pre><code>case zvec::DataType::STRING:\n  doc.set&lt;std::string&gt;(name, ...);\n  break;\ncase zvec::DataType::INT32:\n  doc.set&lt;int32_t&gt;(name, ...);\n  break;\ncase zvec::DataType::VECTOR_FP32: {\n  // Convert Ruby Array \u2192 std::vector&lt;float&gt;\n  Rice::Array arr(value);\n  std::vector&lt;float&gt; vec(arr.size());\n  for (size_t i = 0; i &lt; arr.size(); i++)\n    vec[i] = From_Ruby&lt;float&gt;().convert(arr[i].value());\n  doc.set&lt;std::vector&lt;float&gt;&gt;(name, std::move(vec));\n  break;\n}\n</code></pre> <p>The Ruby-side <code>Doc#to_h(schema)</code> method leverages this by iterating over field names and calling <code>get_field</code> with the data type from the schema.</p>"},{"location":"architecture/native-extension/#sparse-vector-serialization","title":"Sparse Vector Serialization","text":"<p>Sparse vectors are represented differently in Ruby (Hash) and C++ (pair of index/value vectors). The binding handles the conversion:</p> <ul> <li>Ruby \u2192 C++: Hash <code>{ 42 =&gt; 0.8, 99 =&gt; 0.3 }</code> \u2192 <code>pair&lt;vector&lt;uint32_t&gt;, vector&lt;float&gt;&gt;</code></li> <li>C++ \u2192 Ruby: <code>pair&lt;vector&lt;uint32_t&gt;, vector&lt;float&gt;&gt;</code> \u2192 Hash <code>{ 42 =&gt; 0.8, 99 =&gt; 0.3 }</code></li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Working examples are in the <code>examples/</code> directory of the repository.</p> Example Description Basic Usage Schema definition, CRUD operations, and block-form collections with hand-crafted vectors Semantic Search Real text embeddings over markdown documents using the <code>informers</code> gem"},{"location":"examples/#running-examples","title":"Running Examples","text":"<pre><code>bundle exec ruby examples/01_basic_usage.rb\nbundle exec ruby examples/02_semantic_search.rb\n</code></pre> <p>The semantic search example downloads a model (~23 MB) on first run. Subsequent runs use the cached model.</p>"},{"location":"examples/basic-usage/","title":"Basic Usage","text":"<p>Source: <code>examples/01_basic_usage.rb</code></p> <p>This example demonstrates the core zvec workflow using hand-crafted 4-dimensional vectors.</p>"},{"location":"examples/basic-usage/#what-it-covers","title":"What It Covers","text":"<ol> <li>Defining a schema with scalar and vector fields</li> <li>Creating a collection on disk</li> <li>Inserting documents</li> <li>Querying by vector similarity</li> <li>Fetching documents by primary key</li> <li>Deleting documents</li> <li>Block-form <code>open_collection</code></li> </ol>"},{"location":"examples/basic-usage/#schema","title":"Schema","text":"<p>The example creates a \"movies\" collection with four fields:</p> <pre><code>pk_field    = Zvec::FieldSchema.create(\"pk\", Zvec::DataType::STRING)\ntitle_field = Zvec::FieldSchema.create(\"title\", Zvec::DataType::STRING)\nyear_field  = Zvec::FieldSchema.create(\"year\", Zvec::DataType::INT32)\nembedding   = Zvec::FieldSchema.create(\"embedding\", Zvec::DataType::VECTOR_FP32,\n                dimension:    4,\n                index_params: Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE))\n\nschema = Zvec::CollectionSchema.create(\"movies\",\n           [pk_field, title_field, year_field, embedding])\n</code></pre>"},{"location":"examples/basic-usage/#document-helper","title":"Document Helper","text":"<p>A helper method builds a <code>Doc</code> with all fields populated:</p> <pre><code>def make_doc(id, title, year, vector)\n  doc = Zvec::Doc.new\n  doc.pk = id\n  doc.set_field(\"pk\",        Zvec::DataType::STRING,      id)\n  doc.set_field(\"title\",     Zvec::DataType::STRING,      title)\n  doc.set_field(\"year\",      Zvec::DataType::INT32,       year)\n  doc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, vector)\n  doc\nend\n</code></pre>"},{"location":"examples/basic-usage/#sample-data","title":"Sample Data","text":"<p>Five movies with hand-crafted 4D vectors, loosely representing genre characteristics:</p> <pre><code>movies = [\n  make_doc(\"mov1\", \"The Matrix\",        1999, [0.9, 0.1, 0.0, 0.2]),\n  make_doc(\"mov2\", \"Inception\",          2010, [0.8, 0.3, 0.1, 0.1]),\n  make_doc(\"mov3\", \"Interstellar\",       2014, [0.7, 0.5, 0.3, 0.0]),\n  make_doc(\"mov4\", \"The Grand Budapest\", 2014, [0.1, 0.2, 0.9, 0.8]),\n  make_doc(\"mov5\", \"Am\u00e9lie\",             2001, [0.0, 0.1, 0.8, 0.9]),\n]\n</code></pre>"},{"location":"examples/basic-usage/#running","title":"Running","text":"<pre><code>bundle exec ruby examples/01_basic_usage.rb\n</code></pre> <p>Expected output shows inserts, a similarity query, fetch by PK, deletion, and a block-form reopen.</p>"},{"location":"examples/semantic-search/","title":"Semantic Search","text":"<p>Source: <code>examples/02_semantic_search.rb</code></p> <p>This example demonstrates realistic semantic search by using the informers gem to generate real text embeddings from markdown documents, store them in zvec, and query by natural language.</p>"},{"location":"examples/semantic-search/#dependencies","title":"Dependencies","text":"<p>The <code>informers</code> gem (which pulls in <code>onnxruntime</code> and <code>tokenizers</code>) is required. It's included in the project's <code>Gemfile</code> under the development group.</p> <p>The example uses the <code>sentence-transformers/all-MiniLM-L6-v2</code> model, which produces 384-dimensional embeddings. The model (~23 MB) is auto-downloaded on first run and cached for subsequent runs.</p>"},{"location":"examples/semantic-search/#documents","title":"Documents","text":"<p>Five short markdown files in <code>examples/docs/</code> cover distinct topics:</p> File Topic <code>ruby_basics.md</code> Ruby programming language <code>http_protocol.md</code> HTTP and web servers <code>machine_learning.md</code> ML and neural networks <code>cooking_pasta.md</code> Italian pasta cooking <code>solar_system.md</code> Planets and astronomy"},{"location":"examples/semantic-search/#schema","title":"Schema","text":"<p>384-dimensional FP32 vectors with HNSW cosine index:</p> <pre><code>pk_field        = Zvec::FieldSchema.create(\"pk\", Zvec::DataType::STRING)\nfilename_field  = Zvec::FieldSchema.create(\"filename\", Zvec::DataType::STRING)\ncontent_field   = Zvec::FieldSchema.create(\"content\", Zvec::DataType::STRING)\nembedding_field = Zvec::FieldSchema.create(\"embedding\", Zvec::DataType::VECTOR_FP32,\n                    dimension:    384,\n                    index_params: Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE))\n</code></pre>"},{"location":"examples/semantic-search/#how-it-works","title":"How It Works","text":"<ol> <li>Load all <code>.md</code> files from <code>examples/docs/</code></li> <li>Initialize the informers embedding pipeline</li> <li>Generate a 384-dim embedding for each document's text</li> <li>Create a zvec collection in a temp directory, insert all docs</li> <li>For each natural language query, embed the query text and search for the top 3 matches</li> <li>Display results with similarity scores (<code>1.0 - distance</code>)</li> </ol>"},{"location":"examples/semantic-search/#sample-queries-and-results","title":"Sample Queries and Results","text":"<pre><code>Query: \"How do web servers handle requests?\"\n  1. http_protocol.md  (similarity: 0.6172)\n  2. machine_learning.md  (similarity: 0.1089)\n  3. ruby_basics.md  (similarity: 0.1059)\n\nQuery: \"What are neural networks and deep learning?\"\n  1. machine_learning.md  (similarity: 0.6591)\n  2. http_protocol.md  (similarity: 0.1692)\n  3. solar_system.md  (similarity: 0.1075)\n\nQuery: \"How do I cook spaghetti al dente?\"\n  1. cooking_pasta.md  (similarity: 0.6277)\n  2. solar_system.md  (similarity: 0.0473)\n  3. machine_learning.md  (similarity: 0.0106)\n</code></pre> <p>Each query correctly identifies the most relevant document as the top result.</p>"},{"location":"examples/semantic-search/#running","title":"Running","text":"<pre><code>bundle exec ruby examples/02_semantic_search.rb\n</code></pre> <p>First run downloads the model. Subsequent runs use the cached version.</p>"},{"location":"examples/semantic-search/#adapting-for-your-own-documents","title":"Adapting for Your Own Documents","text":"<p>To use this pattern with your own documents, change <code>DOCS_DIR</code> to point at your markdown files:</p> <pre><code>DOCS_DIR = \"/path/to/your/docs\"\n</code></pre> <p>For longer documents, consider splitting them into chunks (paragraphs or sections) before embedding, since transformer models have a limited context window (~512 tokens for all-MiniLM-L6-v2).</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section walks you through setting up your environment, installing the gem, building the native extension, and running your first vector search.</p> <ol> <li>Prerequisites \u2014 Install the required system dependencies (CMake, ICU4C, a C++17 compiler).</li> <li>Installation \u2014 Add the gem to your project and build the native extension with CMake.</li> <li>Quick Start \u2014 Define a schema, create a collection, insert documents, and query by vector similarity.</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#recommended-homebrew-gem-install","title":"Recommended: Homebrew + Gem Install","text":"<p>Pre-build the zvec C++ library with Homebrew, then install the gem:</p> <pre><code>brew tap madbomber/zvec https://github.com/MadBomber/zvec-ruby.git\nbrew install madbomber/zvec/zvec\ngem install zvec          # ~10 seconds\n</code></pre> <p>The gem detects the pre-built library at <code>/opt/homebrew/opt/zvec</code> and only compiles the thin Ruby binding layer.</p>"},{"location":"getting-started/installation/#alternative-source-build","title":"Alternative: Source Build","text":"<p>Without the Homebrew formula, the gem downloads and compiles the full C++ dependency tree from source:</p> <pre><code>gem install zvec          # ~10 minutes\n</code></pre> <p>This fetches zvec and all its dependencies (Arrow, RocksDB, protobuf, etc.) via CMake's FetchContent during the extension build. It requires CMake, a C++17 compiler, Ninja, and ICU4C.</p>"},{"location":"getting-started/installation/#development-setup","title":"Development Setup","text":"<p>For contributing or working on the gem itself:</p>"},{"location":"getting-started/installation/#clone-with-submodules","title":"Clone with Submodules","text":"<pre><code>git clone --recurse-submodules https://github.com/MadBomber/zvec-ruby.git\ncd zvec-ruby\nbundle install\n</code></pre>"},{"location":"getting-started/installation/#build-the-native-extension","title":"Build the Native Extension","text":"<p>The native extension uses CMake (not the traditional <code>extconf.rb</code> approach). Two presets are available:</p> Release (recommended)Debug <pre><code>cd ext\ncmake --preset macos-release\ncmake --build build/macos-release\ncd ..\n</code></pre> <pre><code>cd ext\ncmake --preset macos-debug\ncmake --build build/macos-debug\ncd ..\n</code></pre> <p>The build outputs <code>zvec_ext.bundle</code> directly to the <code>lib/</code> directory.</p>"},{"location":"getting-started/installation/#verify-the-installation","title":"Verify the Installation","text":"<p>Launch the interactive console:</p> <pre><code>bin/console\n</code></pre> <pre><code>irb&gt; Zvec::VERSION\n=&gt; \"0.0.1\"\nirb&gt; Zvec::DataType::VECTOR_FP32\n=&gt; VECTOR_FP32\n</code></pre>"},{"location":"getting-started/installation/#build-presets","title":"Build Presets","text":"<p>The available CMake presets are defined in <code>ext/CMakePresets.json</code>:</p> Preset Build Type C++ Flags Use Case <code>macos-debug</code> Debug <code>-g -O0</code> Development, debugging with lldb <code>macos-release</code> Release <code>-O3 -DNDEBUG</code> Performance, benchmarking <p>Both presets use the Ninja generator and set <code>CMAKE_PREFIX_PATH</code> to the Homebrew ICU4C path.</p>"},{"location":"getting-started/installation/#how-the-build-resolves-zvec","title":"How the Build Resolves zvec","text":"<p>The gem's CMakeLists.txt uses a three-tier resolution strategy:</p> <ol> <li>Pre-installed library \u2014 Checks for <code>libzvec.a</code> at <code>/opt/homebrew/opt/zvec/lib</code> (from <code>brew install zvec</code>). If found, links against it directly. Fast.</li> <li>Local submodule \u2014 Uses <code>vendor/zvec</code> if present (development checkout with <code>--recurse-submodules</code>). Builds from source.</li> <li>FetchContent \u2014 Downloads zvec from GitHub and builds everything from source. Slowest but works anywhere.</li> </ol>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#icu4c-not-found","title":"ICU4C not found","text":"<p>If the build fails with <code>'unicode/ucnv.h' file not found</code>:</p> <pre><code>brew install icu4c@78\n</code></pre> <p>The CMake build automatically adds <code>/opt/homebrew/opt/icu4c@78</code> to the search path. If your Homebrew prefix is different (e.g., <code>/usr/local</code> on Intel Macs), pass it explicitly:</p> <pre><code>gem install zvec -- -DCMAKE_PREFIX_PATH=/usr/local/opt/icu4c@78\n</code></pre>"},{"location":"getting-started/installation/#gem-install-is-slow","title":"gem install is slow","text":"<p>Install the Homebrew formula first:</p> <pre><code>brew tap madbomber/zvec https://github.com/MadBomber/zvec-ruby.git\nbrew install madbomber/zvec/zvec\n</code></pre> <p>Then <code>gem install zvec</code> will use the pre-built library and finish in seconds.</p>"},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":"<p>Zvec requires a few system dependencies before you can build the native extension.</p>"},{"location":"getting-started/prerequisites/#ruby","title":"Ruby","text":"<p>Ruby 3.2.0 or later is required.</p> <pre><code>ruby --version\n</code></pre>"},{"location":"getting-started/prerequisites/#cmake","title":"CMake","text":"<p>CMake 3.26 or later is needed to build the C++ extension.</p> macOS (Homebrew)Ubuntu/Debian <pre><code>brew install cmake ninja\n</code></pre> <pre><code>sudo apt-get install cmake ninja-build\n</code></pre>"},{"location":"getting-started/prerequisites/#icu4c","title":"ICU4C","text":"<p>The zvec C++ library depends on ICU for Unicode support (via Apache Arrow).</p> macOS (Homebrew)Ubuntu/Debian <pre><code>brew install icu4c@78\n</code></pre> <p>The CMake build expects ICU at <code>/opt/homebrew/opt/icu4c@78</code>. If your Homebrew prefix differs, adjust the <code>CMAKE_PREFIX_PATH</code> in <code>ext/CMakePresets.json</code>.</p> <pre><code>sudo apt-get install libicu-dev\n</code></pre>"},{"location":"getting-started/prerequisites/#c-compiler","title":"C++ Compiler","text":"<p>A C++17-capable compiler is required:</p> <ul> <li>macOS: Xcode Command Line Tools (<code>xcode-select --install</code>)</li> <li>Linux: GCC 9+ or Clang 10+</li> </ul>"},{"location":"getting-started/prerequisites/#optional-pre-built-zvec-library-recommended","title":"Optional: Pre-built zvec Library (Recommended)","text":"<p>Pre-building the zvec C++ library with Homebrew makes <code>gem install zvec</code> fast (~10 seconds instead of ~10 minutes):</p> <pre><code>brew tap madbomber/zvec https://github.com/MadBomber/zvec-ruby.git\nbrew install madbomber/zvec/zvec\n</code></pre> <p>Without this, the gem will download and compile the full C++ dependency tree (Arrow, RocksDB, protobuf, etc.) from source during installation.</p>"},{"location":"getting-started/prerequisites/#verifying-your-environment","title":"Verifying Your Environment","text":"<p>Run the following to confirm everything is in place:</p> <pre><code>ruby --version      # &gt;= 3.2.0\ncmake --version     # &gt;= 3.26\nninja --version     # any recent version\n</code></pre> <p>If you installed the Homebrew formula:</p> <pre><code>brew info zvec      # shows installed version and prefix\npkg-config --libs zvec  # should print -Wl,-force_load,...\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide walks through a complete workflow: defining a schema, creating a collection, inserting documents, querying by vector similarity, and cleaning up.</p>"},{"location":"getting-started/quick-start/#1-define-a-schema","title":"1. Define a Schema","text":"<p>Every collection needs at least a primary key field and one vector field. Scalar fields store metadata alongside vectors.</p> <pre><code>require \"zvec\"\nrequire \"tmpdir\"\n\npk    = Zvec::FieldSchema.create(\"pk\", Zvec::DataType::STRING)\ntitle = Zvec::FieldSchema.create(\"title\", Zvec::DataType::STRING)\nyear  = Zvec::FieldSchema.create(\"year\", Zvec::DataType::INT32)\n\nembedding = Zvec::FieldSchema.create(\"embedding\", Zvec::DataType::VECTOR_FP32,\n              dimension:    4,\n              index_params: Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE))\n\nschema = Zvec::CollectionSchema.create(\"movies\", [pk, title, year, embedding])\n</code></pre>"},{"location":"getting-started/quick-start/#2-create-a-collection","title":"2. Create a Collection","text":"<p>A collection is stored on disk at a specified path. Use <code>create_and_open</code> for new collections:</p> <pre><code>col = Zvec::Collection.create_and_open(\"/tmp/my_movies\", schema)\n</code></pre> <p>Or use a temporary directory for experiments:</p> <pre><code>Dir.mktmpdir(\"zvec\") do |dir|\n  col = Zvec::Collection.create_and_open(File.join(dir, \"movies\"), schema)\n  # ... work with col ...\nend\n</code></pre>"},{"location":"getting-started/quick-start/#3-insert-documents","title":"3. Insert Documents","text":"<p>Build <code>Doc</code> objects with typed fields matching your schema:</p> <pre><code>doc = Zvec::Doc.new\ndoc.pk = \"mov1\"\ndoc.set_field(\"pk\",        Zvec::DataType::STRING,      \"mov1\")\ndoc.set_field(\"title\",     Zvec::DataType::STRING,      \"The Matrix\")\ndoc.set_field(\"year\",      Zvec::DataType::INT32,       1999)\ndoc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, [0.9, 0.1, 0.0, 0.2])\n\nstatuses = col.insert([doc])\nstatuses.each { |s| puts s }  # =&gt; \"OK\"\n\ncol.flush  # persist to disk\n</code></pre>"},{"location":"getting-started/quick-start/#4-query-by-vector-similarity","title":"4. Query by Vector Similarity","text":"<p>Find the most similar documents to a query vector:</p> <pre><code>results = col.query_vector(\"embedding\", [0.85, 0.2, 0.05, 0.15], top_k: 3)\n\nresults.each do |doc|\n  h = doc.to_h(col.schema)\n  puts \"#{h['title']} (#{h['year']})  score=#{h['score']}\"\nend\n</code></pre> <p>Score Interpretation</p> <p>The <code>score</code> field contains the distance between vectors. For cosine distance, 0 means identical and values closer to 0 indicate higher similarity. To convert to a similarity value where higher is better, use <code>1.0 - score</code>.</p>"},{"location":"getting-started/quick-start/#5-fetch-by-primary-key","title":"5. Fetch by Primary Key","text":"<p>Retrieve specific documents without a vector search:</p> <pre><code>docs = col.fetch([\"mov1\"])\ndocs.each do |pk, doc|\n  h = doc.to_h(col.schema)\n  puts \"#{pk}: #{h['title']}\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#6-delete-documents","title":"6. Delete Documents","text":"<pre><code>col.delete([\"mov1\"])\ncol.flush\n</code></pre>"},{"location":"getting-started/quick-start/#7-block-form-collections","title":"7. Block-Form Collections","text":"<p><code>Zvec.open_collection</code> opens an existing collection, yields it, and auto-flushes on block exit:</p> <pre><code>Zvec.open_collection(\"/tmp/my_movies\") do |col|\n  results = col.query_vector(\"embedding\", [0.1, 0.2, 0.3, 0.4], top_k: 5)\n  # ...\nend\n# col is flushed automatically here\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Schemas and Fields \u2014 Learn about all supported data types and field options.</li> <li>Vector Search \u2014 Understand distance metrics, query parameters, and result scoring.</li> <li>Examples \u2014 See complete working examples.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>In-depth guides covering each aspect of working with zvec.</p> <ul> <li>Schemas and Fields \u2014 Data types, vector types, field options, and nullable fields.</li> <li>Documents \u2014 Creating, reading, and converting <code>Doc</code> objects.</li> <li>Collections \u2014 Creating, opening, flushing, and destroying collections.</li> <li>Vector Search \u2014 Similarity queries, distance metrics, and result scoring.</li> <li>Filtered Queries \u2014 Combining vector search with scalar predicates.</li> <li>Index Tuning \u2014 HNSW, IVF, and Flat index parameters for performance tuning.</li> <li>Configuration \u2014 Global settings for memory limits, threading, and logging.</li> <li>Error Handling \u2014 Exception hierarchy and error recovery patterns.</li> </ul>"},{"location":"guides/collections/","title":"Collections","text":"<p>A collection is a persistent, on-disk container for documents. It owns the schema, the vector indexes, and the forward storage for scalar fields.</p>"},{"location":"guides/collections/#creating-a-collection","title":"Creating a Collection","text":"<p>Use <code>create_and_open</code> to create a new collection at a file system path:</p> <pre><code>col = Zvec::Collection.create_and_open(\"/path/to/my_collection\", schema)\n</code></pre> <p>This creates the directory structure on disk and returns an open collection handle.</p> <p>Warning</p> <p>Calling <code>create_and_open</code> on a path that already exists raises <code>Zvec::AlreadyExistsError</code>.</p>"},{"location":"guides/collections/#opening-an-existing-collection","title":"Opening an Existing Collection","text":"<pre><code>col = Zvec::Collection.open(\"/path/to/my_collection\")\n</code></pre> <p>Raises <code>Zvec::NotFoundError</code> if the path does not contain a valid collection.</p>"},{"location":"guides/collections/#block-form-open","title":"Block-Form Open","text":"<p><code>Zvec.open_collection</code> yields the collection and auto-flushes when the block exits:</p> <pre><code>Zvec.open_collection(\"/path/to/my_collection\") do |col|\n  results = col.query_vector(\"embedding\", query_vec, top_k: 5)\n  # ...\nend\n# col is flushed automatically here\n</code></pre>"},{"location":"guides/collections/#collection-options","title":"Collection Options","text":"<p>Pass a <code>CollectionOptions</code> object to control how a collection is opened:</p> <pre><code>opts = Zvec::CollectionOptions.new\nopts.read_only = true       # open in read-only mode\nopts.enable_mmap = true     # memory-map data files\nopts.max_buffer_size = 4096 # write buffer size\n\ncol = Zvec::Collection.open(\"/path/to/my_collection\", options: opts)\n</code></pre>"},{"location":"guides/collections/#writing-documents","title":"Writing Documents","text":""},{"location":"guides/collections/#insert","title":"Insert","text":"<pre><code>statuses = col.insert([doc1, doc2, doc3])\nstatuses.each { |s| puts s.ok? ? \"OK\" : s.message }\n</code></pre> <p>Returns an array of <code>Status</code> objects, one per document.</p>"},{"location":"guides/collections/#upsert","title":"Upsert","text":"<p>Insert or replace existing documents by primary key:</p> <pre><code>statuses = col.upsert([doc])\n</code></pre>"},{"location":"guides/collections/#update","title":"Update","text":"<p>Update fields on existing documents:</p> <pre><code>statuses = col.update([doc])\n</code></pre>"},{"location":"guides/collections/#flushing","title":"Flushing","text":"<p>Writes are buffered in memory. Call <code>flush</code> to persist to disk:</p> <pre><code>col.flush\n</code></pre> <p>The block-form <code>Zvec.open_collection</code> flushes automatically on block exit.</p>"},{"location":"guides/collections/#reading-documents","title":"Reading Documents","text":""},{"location":"guides/collections/#fetch-by-primary-key","title":"Fetch by Primary Key","text":"<pre><code>docs = col.fetch([\"pk1\", \"pk2\", \"pk3\"])\ndocs.each do |pk, doc|\n  h = doc.to_h(col.schema)\n  puts \"#{pk}: #{h['title']}\"\nend\n</code></pre> <p>Returns a hash mapping primary keys to <code>Doc</code> objects. Missing keys are omitted.</p>"},{"location":"guides/collections/#vector-query","title":"Vector Query","text":"<p>See Vector Search for the full query interface.</p> <pre><code>results = col.query_vector(\"embedding\", query_vec, top_k: 10)\n</code></pre>"},{"location":"guides/collections/#deleting-documents","title":"Deleting Documents","text":""},{"location":"guides/collections/#delete-by-primary-key","title":"Delete by Primary Key","text":"<pre><code>statuses = col.delete([\"pk1\", \"pk2\"])\ncol.flush\n</code></pre>"},{"location":"guides/collections/#delete-by-filter","title":"Delete by Filter","text":"<pre><code>col.delete_by_filter(\"year &lt; 2000\")\ncol.flush\n</code></pre>"},{"location":"guides/collections/#collection-metadata","title":"Collection Metadata","text":"<pre><code>col.path     # =&gt; \"/path/to/my_collection\"\ncol.schema   # =&gt; CollectionSchema\ncol.stats    # =&gt; CollectionStats\ncol.options  # =&gt; CollectionOptions\n</code></pre>"},{"location":"guides/collections/#collection-stats","title":"Collection Stats","text":"<pre><code>stats = col.stats\nstats.doc_count            # =&gt; 42\nstats.index_completeness   # =&gt; {\"embedding\" =&gt; 1.0}\n</code></pre>"},{"location":"guides/collections/#schema-modification","title":"Schema Modification","text":""},{"location":"guides/collections/#add-a-column","title":"Add a Column","text":"<pre><code>new_field = Zvec::FieldSchema.create(\"category\", Zvec::DataType::STRING)\ncol.add_column(new_field)\n</code></pre> <p>With a default expression:</p> <pre><code>col.add_column(new_field, expression: \"'unknown'\")\n</code></pre>"},{"location":"guides/collections/#drop-a-column","title":"Drop a Column","text":"<pre><code>col.drop_column(\"category\")\n</code></pre>"},{"location":"guides/collections/#alter-a-column","title":"Alter a Column","text":"<p>Rename a column or change its schema:</p> <pre><code>col.alter_column(\"old_name\", rename: \"new_name\")\n</code></pre>"},{"location":"guides/collections/#index-management","title":"Index Management","text":""},{"location":"guides/collections/#create-an-index","title":"Create an Index","text":"<p>Add an index to an existing column:</p> <pre><code>params = Zvec::InvertIndexParams.new\ncol.create_index(\"category\", params)\n</code></pre>"},{"location":"guides/collections/#drop-an-index","title":"Drop an Index","text":"<pre><code>col.drop_index(\"category\")\n</code></pre>"},{"location":"guides/collections/#optimize","title":"Optimize","text":"<p>Compact and optimize indexes:</p> <pre><code>col.optimize\n</code></pre>"},{"location":"guides/collections/#destroying-a-collection","title":"Destroying a Collection","text":"<p>Permanently delete the collection and all its data from disk:</p> <pre><code>col.destroy!\n</code></pre> <p>Danger</p> <p>This is irreversible. All data is deleted.</p>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>Zvec provides global configuration for memory limits, threading, and logging. Call <code>Zvec.configure</code> before creating or opening collections.</p>"},{"location":"guides/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>Zvec.configure(\n  memory_limit_mb: 512,\n  query_thread_count: 4,\n  optimize_thread_count: 2\n)\n</code></pre>"},{"location":"guides/configuration/#options","title":"Options","text":"Option Type Description <code>memory_limit_mb</code> Integer Maximum memory usage in megabytes <code>query_thread_count</code> Integer Number of threads for query execution <code>optimize_thread_count</code> Integer Number of threads for index optimization <code>invert_to_forward_scan_ratio</code> Float Threshold for switching between inverted index lookup and forward scan <code>brute_force_by_keys_ratio</code> Float Threshold for switching to brute-force search by keys"},{"location":"guides/configuration/#logging","title":"Logging","text":""},{"location":"guides/configuration/#console-logging","title":"Console Logging","text":"<pre><code>Zvec.configure(\n  log_type: \"console\",\n  log_level: Zvec::LogLevel::INFO\n)\n</code></pre>"},{"location":"guides/configuration/#file-logging","title":"File Logging","text":"<pre><code>Zvec.configure(\n  log_type: \"file\",\n  log_level: Zvec::LogLevel::WARN,\n  log_dir: \"./logs\",\n  log_basename: \"zvec.log\",\n  log_file_size: 2048,       # max file size in KB\n  log_overdue_days: 7         # days before log rotation\n)\n</code></pre>"},{"location":"guides/configuration/#log-levels","title":"Log Levels","text":"Level Constant Description Debug <code>LogLevel::DEBUG</code> Verbose diagnostic output Info <code>LogLevel::INFO</code> General operational messages Warn <code>LogLevel::WARN</code> Potential issues (default) Error <code>LogLevel::ERROR</code> Error conditions Fatal <code>LogLevel::FATAL</code> Critical failures"},{"location":"guides/configuration/#configuration-timing","title":"Configuration Timing","text":"<p><code>Zvec.configure</code> must be called before any collections are created or opened. Calling it after initialization raises an error.</p> <pre><code># Correct order\nZvec.configure(memory_limit_mb: 256)\ncol = Zvec::Collection.create_and_open(path, schema)\n</code></pre>"},{"location":"guides/documents/","title":"Documents","text":"<p>A <code>Zvec::Doc</code> is a typed key-value container that holds a single record's data. Documents carry a primary key, typed fields, a score (populated after queries), and an operator flag.</p>"},{"location":"guides/documents/#creating-a-document","title":"Creating a Document","text":"<pre><code>doc = Zvec::Doc.new\ndoc.pk = \"item1\"\ndoc.set_field(\"pk\",    Zvec::DataType::STRING, \"item1\")\ndoc.set_field(\"title\", Zvec::DataType::STRING, \"Example\")\ndoc.set_field(\"year\",  Zvec::DataType::INT32,  2024)\ndoc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, [0.1, 0.2, 0.3, 0.4])\n</code></pre> <p>Important</p> <p>Always set both <code>doc.pk</code> and the primary key field via <code>set_field</code>. The <code>pk</code> attribute is used by zvec internally for indexing, while <code>set_field</code> stores the value for retrieval.</p>"},{"location":"guides/documents/#setting-fields","title":"Setting Fields","text":"<p>The <code>set_field</code> method requires three arguments: field name, data type, and value.</p> <pre><code>doc.set_field(name, data_type, value)\n</code></pre> <p>The data type must match the field's schema definition. Passing the wrong type results in a conversion error.</p>"},{"location":"guides/documents/#scalar-fields","title":"Scalar Fields","text":"<pre><code>doc.set_field(\"name\",   Zvec::DataType::STRING, \"Alice\")\ndoc.set_field(\"active\", Zvec::DataType::BOOL,   true)\ndoc.set_field(\"age\",    Zvec::DataType::INT32,   30)\ndoc.set_field(\"score\",  Zvec::DataType::FLOAT,   0.95)\n</code></pre>"},{"location":"guides/documents/#dense-vectors","title":"Dense Vectors","text":"<p>Pass a Ruby array of numbers:</p> <pre><code>doc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, [0.1, 0.2, 0.3, 0.4])\n</code></pre> <p>The array length must match the field's <code>dimension</code>.</p>"},{"location":"guides/documents/#sparse-vectors","title":"Sparse Vectors","text":"<p>Pass a Ruby hash mapping integer indices to float values:</p> <pre><code>doc.set_field(\"sparse\", Zvec::DataType::SPARSE_VECTOR_FP32, { 42 =&gt; 0.8, 99 =&gt; 0.3 })\n</code></pre>"},{"location":"guides/documents/#array-fields","title":"Array Fields","text":"<p>Pass a Ruby array of the appropriate scalar type:</p> <pre><code>doc.set_field(\"tags\", Zvec::DataType::ARRAY_STRING, [\"ruby\", \"database\", \"vector\"])\n</code></pre>"},{"location":"guides/documents/#null-values","title":"Null Values","text":"<p>For nullable fields, pass <code>nil</code>:</p> <pre><code>doc.set_field(\"bio\", Zvec::DataType::STRING, nil)\n</code></pre>"},{"location":"guides/documents/#reading-fields","title":"Reading Fields","text":"<p>Use <code>get_field</code> with the field name and data type:</p> <pre><code>title = doc.get_field(\"title\", Zvec::DataType::STRING)   # =&gt; \"Example\"\nyear  = doc.get_field(\"year\",  Zvec::DataType::INT32)     # =&gt; 2024\nvec   = doc.get_field(\"embedding\", Zvec::DataType::VECTOR_FP32)  # =&gt; [0.1, 0.2, ...]\n</code></pre> <p>Returns <code>nil</code> if the field is absent or null.</p>"},{"location":"guides/documents/#alternative-set_field_by_schema","title":"Alternative: set_field_by_schema","text":"<p>If you have a <code>FieldSchema</code> reference, you can use it for type dispatch instead of passing the data type explicitly:</p> <pre><code>fs = schema.get_field(\"title\")\ndoc.set_field_by_schema(\"title\", fs, \"New Title\")\n</code></pre>"},{"location":"guides/documents/#converting-to-a-hash","title":"Converting to a Hash","text":"<p><code>Doc#to_h(schema)</code> converts all fields to a Ruby hash, using the schema for type dispatch:</p> <pre><code>h = doc.to_h(col.schema)\n# =&gt; {\"pk\"=&gt;\"item1\", \"score\"=&gt;0.0, \"title\"=&gt;\"Example\", \"year\"=&gt;2024, \"embedding\"=&gt;[0.1, ...]}\n</code></pre> <p>The hash always includes <code>pk</code> and <code>score</code> keys.</p>"},{"location":"guides/documents/#document-metadata","title":"Document Metadata","text":"<pre><code>doc.pk         # =&gt; \"item1\" (primary key)\ndoc.score      # =&gt; 0.0 (distance, populated after query)\ndoc.doc_id     # =&gt; internal document ID\ndoc.operator   # =&gt; INSERT, UPSERT, UPDATE, or DELETE\n</code></pre>"},{"location":"guides/documents/#inspecting-fields","title":"Inspecting Fields","text":"<pre><code>doc.field_names     # =&gt; [\"pk\", \"title\", \"year\", \"embedding\"]\ndoc.has_field?(\"title\")  # =&gt; true\ndoc.has_value?(\"title\")  # =&gt; true (has non-null value)\ndoc.null?(\"bio\")         # =&gt; true (field is null)\ndoc.empty?               # =&gt; false (has at least one field)\n</code></pre>"},{"location":"guides/documents/#modifying-fields","title":"Modifying Fields","text":"<pre><code>doc.remove_field(\"year\")   # remove a single field\ndoc.clear                  # remove all fields\n</code></pre>"},{"location":"guides/error-handling/","title":"Error Handling","text":"<p>Zvec maps C++ status codes to a Ruby exception hierarchy. All exceptions inherit from <code>Zvec::Error</code>, which inherits from <code>StandardError</code>.</p>"},{"location":"guides/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>StandardError\n  \u2514\u2500\u2500 Zvec::Error\n        \u251c\u2500\u2500 Zvec::NotFoundError\n        \u251c\u2500\u2500 Zvec::AlreadyExistsError\n        \u251c\u2500\u2500 Zvec::InvalidArgumentError\n        \u251c\u2500\u2500 Zvec::PermissionDeniedError\n        \u251c\u2500\u2500 Zvec::FailedPreconditionError\n        \u251c\u2500\u2500 Zvec::ResourceExhaustedError\n        \u251c\u2500\u2500 Zvec::UnavailableError\n        \u251c\u2500\u2500 Zvec::InternalError\n        \u2514\u2500\u2500 Zvec::NotSupportedError\n</code></pre>"},{"location":"guides/error-handling/#exception-details","title":"Exception Details","text":"Exception Status Code Common Cause <code>NotFoundError</code> <code>NOT_FOUND</code> Collection path doesn't exist, field not in schema <code>AlreadyExistsError</code> <code>ALREADY_EXISTS</code> Creating a collection at a path that already exists <code>InvalidArgumentError</code> <code>INVALID_ARGUMENT</code> Wrong data type, dimension mismatch, malformed filter <code>PermissionDeniedError</code> <code>PERMISSION_DENIED</code> Writing to a read-only collection <code>FailedPreconditionError</code> <code>FAILED_PRECONDITION</code> Operation requires a condition that isn't met <code>ResourceExhaustedError</code> <code>RESOURCE_EXHAUSTED</code> Memory limit reached <code>UnavailableError</code> <code>UNAVAILABLE</code> Internal resource temporarily unavailable <code>InternalError</code> <code>INTERNAL_ERROR</code> Unexpected internal failure <code>NotSupportedError</code> <code>NOT_SUPPORTED</code> Feature not supported for this configuration"},{"location":"guides/error-handling/#handling-errors","title":"Handling Errors","text":""},{"location":"guides/error-handling/#catch-a-specific-exception","title":"Catch a Specific Exception","text":"<pre><code>begin\n  col = Zvec::Collection.open(\"/nonexistent/path\")\nrescue Zvec::NotFoundError =&gt; e\n  puts \"Collection not found: #{e.message}\"\nend\n</code></pre>"},{"location":"guides/error-handling/#catch-all-zvec-errors","title":"Catch All Zvec Errors","text":"<pre><code>begin\n  col.insert([doc])\nrescue Zvec::Error =&gt; e\n  puts \"Zvec error: #{e.message}\"\nend\n</code></pre>"},{"location":"guides/error-handling/#check-insert-status","title":"Check Insert Status","text":"<p>Insert, upsert, update, and delete return an array of <code>Status</code> objects \u2014 one per document. These do not raise exceptions; check them individually:</p> <pre><code>statuses = col.insert([doc1, doc2, doc3])\n\nstatuses.each_with_index do |status, i|\n  if status.ok?\n    puts \"Document #{i} inserted\"\n  else\n    puts \"Document #{i} failed: #{status.message} (code: #{status.code})\"\n  end\nend\n</code></pre>"},{"location":"guides/error-handling/#status-objects","title":"Status Objects","text":"<p>The <code>Zvec::Status</code> class wraps C++ status codes:</p> <pre><code>status.ok?      # =&gt; true if successful\nstatus.code     # =&gt; StatusCode enum value\nstatus.message  # =&gt; human-readable error message\nstatus.to_s     # =&gt; \"OK\" or \"Error(code): message\"\n</code></pre>"},{"location":"guides/error-handling/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"guides/error-handling/#dimension-mismatch","title":"Dimension Mismatch","text":"<p>Inserting a vector with the wrong number of dimensions:</p> <pre><code># Schema defines dimension: 384\ndoc.set_field(\"embedding\", Zvec::DataType::VECTOR_FP32, [0.1, 0.2])  # only 2 dims\ncol.insert([doc])  # status will indicate an error\n</code></pre>"},{"location":"guides/error-handling/#duplicate-primary-key","title":"Duplicate Primary Key","text":"<p>Inserting a document with a primary key that already exists:</p> <pre><code>col.insert([doc])  # first insert: OK\ncol.insert([doc])  # second insert: error status (use upsert instead)\n</code></pre>"},{"location":"guides/error-handling/#read-only-collection","title":"Read-Only Collection","text":"<p>Writing to a collection opened in read-only mode:</p> <pre><code>opts = Zvec::CollectionOptions.new\nopts.read_only = true\ncol = Zvec::Collection.open(path, options: opts)\n\ncol.insert([doc])  # raises Zvec::PermissionDeniedError\n</code></pre>"},{"location":"guides/filtered-queries/","title":"Filtered Queries","text":"<p>Zvec supports combining vector similarity search with scalar predicates. Filters narrow the candidate set before (or during) the vector search, returning only documents that match both the filter and the similarity criteria.</p>"},{"location":"guides/filtered-queries/#basic-filtering","title":"Basic Filtering","text":"<p>Pass a <code>filter</code> string to <code>query_vector</code>:</p> <pre><code>results = col.query_vector(\"embedding\", query_vec,\n            top_k: 5,\n            filter: \"year &gt; 2020\")\n</code></pre> <p>Or via <code>VectorQuery</code>:</p> <pre><code>vq = Zvec::VectorQuery.new\nvq.topk = 5\nvq.field_name = \"embedding\"\nvq.filter = \"year &gt; 2020 AND category = 'science'\"\n</code></pre>"},{"location":"guides/filtered-queries/#filter-syntax","title":"Filter Syntax","text":"<p>Filters use a SQL-like expression language:</p>"},{"location":"guides/filtered-queries/#comparison-operators","title":"Comparison Operators","text":"Operator Example <code>=</code> <code>category = 'science'</code> <code>!=</code> <code>status != 'draft'</code> <code>&gt;</code> <code>year &gt; 2020</code> <code>&gt;=</code> <code>score &gt;= 0.5</code> <code>&lt;</code> <code>price &lt; 100</code> <code>&lt;=</code> <code>count &lt;= 10</code>"},{"location":"guides/filtered-queries/#logical-operators","title":"Logical Operators","text":"Operator Example <code>AND</code> <code>year &gt; 2020 AND category = 'science'</code> <code>OR</code> <code>category = 'science' OR category = 'tech'</code> <code>NOT</code> <code>NOT status = 'archived'</code>"},{"location":"guides/filtered-queries/#string-matching","title":"String Matching","text":"Operator Example Description <code>LIKE</code> <code>title LIKE '%ruby%'</code> Wildcard matching"},{"location":"guides/filtered-queries/#parentheses","title":"Parentheses","text":"<p>Group expressions with parentheses for complex logic:</p> <pre><code>filter: \"(year &gt; 2020 AND year &lt; 2025) OR featured = true\"\n</code></pre>"},{"location":"guides/filtered-queries/#scalar-indexes","title":"Scalar Indexes","text":"<p>For best filter performance, add an inverted index to frequently filtered fields:</p> <pre><code># When defining the schema\ncategory = Zvec::FieldSchema.create(\"category\", Zvec::DataType::STRING,\n             index_params: Zvec::InvertIndexParams.new)\n\n# Or add to an existing collection\ncol.create_index(\"category\", Zvec::InvertIndexParams.new)\n</code></pre> <p>Without an inverted index, filters still work but require a full scan of the forward storage.</p>"},{"location":"guides/filtered-queries/#delete-by-filter","title":"Delete by Filter","text":"<p>You can also use filter expressions to delete documents:</p> <pre><code>col.delete_by_filter(\"year &lt; 2000\")\ncol.flush\n</code></pre>"},{"location":"guides/index-tuning/","title":"Index Tuning","text":"<p>Zvec supports three vector index types, each with tunable parameters that trade off between search speed, accuracy, and memory usage.</p>"},{"location":"guides/index-tuning/#hnsw-hierarchical-navigable-small-world","title":"HNSW (Hierarchical Navigable Small World)","text":"<p>The default and most versatile index type. Good for most use cases.</p>"},{"location":"guides/index-tuning/#index-parameters","title":"Index Parameters","text":"<pre><code>params = Zvec::HnswIndexParams.new(\n  Zvec::MetricType::COSINE,  # distance metric\n  m: 50,                      # max connections per node (default: 50)\n  ef_construction: 500         # search width during build (default: 500)\n)\n</code></pre> Parameter Default Effect <code>m</code> 50 Higher = better recall, more memory, slower inserts <code>ef_construction</code> 500 Higher = better index quality, slower build time"},{"location":"guides/index-tuning/#query-parameters","title":"Query Parameters","text":"<pre><code>qp = Zvec::HnswQueryParams.new(\n  ef: 300,                # search width at query time (default: 300)\n  radius: 0.0,            # max distance threshold (0 = unlimited)\n  is_linear: false,        # force linear scan instead of HNSW\n  is_using_refiner: false  # re-rank with exact distances\n)\n\nresults = col.query_vector(\"embedding\", query_vec, top_k: 10, query_params: qp)\n</code></pre> Parameter Default Effect <code>ef</code> 300 Higher = better recall, slower query <code>radius</code> 0.0 Filter results beyond this distance (0 = no filter) <code>linear</code> false Bypass HNSW index for exact brute-force search <code>using_refiner</code> false Re-rank candidates with exact distance computation <p>Tuning ef</p> <p>Start with <code>ef</code> equal to <code>top_k * 10</code>. Increase if recall is insufficient. Decrease for faster queries when approximate results are acceptable.</p>"},{"location":"guides/index-tuning/#ivf-inverted-file-index","title":"IVF (Inverted File Index)","text":"<p>Partitions vectors into clusters. Good for larger datasets where HNSW memory usage is a concern.</p>"},{"location":"guides/index-tuning/#index-parameters_1","title":"Index Parameters","text":"<pre><code>params = Zvec::IVFIndexParams.new(\n  Zvec::MetricType::COSINE,\n  n_list: 1024,       # number of clusters (default: 1024)\n  n_iters: 10,        # k-means iterations during build (default: 10)\n  use_soar: false      # use SOAR optimization (default: false)\n)\n</code></pre> Parameter Default Effect <code>n_list</code> 1024 More clusters = finer partitioning, higher build cost <code>n_iters</code> 10 More iterations = better cluster quality, slower build <code>use_soar</code> false Enable SOAR optimization for better recall"},{"location":"guides/index-tuning/#query-parameters_1","title":"Query Parameters","text":"<pre><code>qp = Zvec::IVFQueryParams.new(\n  nprobe: 10,              # clusters to search (default: 10)\n  is_using_refiner: false,  # re-rank with exact distances\n  scale_factor: 10.0        # internal scaling factor (default: 10.0)\n)\n</code></pre> Parameter Default Effect <code>nprobe</code> 10 More probes = better recall, slower query <code>scale_factor</code> 10.0 Internal tuning parameter"},{"location":"guides/index-tuning/#flat-exact-search","title":"Flat (Exact Search)","text":"<p>Brute-force exact search with no approximation. Best for small datasets or when perfect recall is required.</p>"},{"location":"guides/index-tuning/#index-parameters_2","title":"Index Parameters","text":"<pre><code>params = Zvec::FlatIndexParams.new(Zvec::MetricType::COSINE)\n</code></pre> <p>No tuning parameters \u2014 every query compares against all vectors.</p>"},{"location":"guides/index-tuning/#query-parameters_2","title":"Query Parameters","text":"<pre><code>qp = Zvec::FlatQueryParams.new(\n  is_using_refiner: false,\n  scale_factor: 10.0\n)\n</code></pre>"},{"location":"guides/index-tuning/#inverted-index-scalar-fields","title":"Inverted Index (Scalar Fields)","text":"<p>For scalar fields used in filters, an inverted index speeds up predicate evaluation:</p> <pre><code>params = Zvec::InvertIndexParams.new(\n  enable_range_optimization: true,   # optimize range queries (default: true)\n  enable_extended_wildcard: false     # extended wildcard patterns (default: false)\n)\n</code></pre>"},{"location":"guides/index-tuning/#quantization","title":"Quantization","text":"<p>All vector index types support quantization to reduce memory usage at the cost of some precision:</p> <pre><code>params = Zvec::HnswIndexParams.new(\n  Zvec::MetricType::COSINE,\n  quantize_type: Zvec::QuantizeType::INT8  # quantize from FP32 to INT8\n)\n</code></pre> Quantization Compression Precision Loss <code>QuantizeType::FP16</code> 2x Minimal <code>QuantizeType::INT8</code> 4x Low <code>QuantizeType::INT4</code> 8x Moderate"},{"location":"guides/index-tuning/#index-lifecycle","title":"Index Lifecycle","text":""},{"location":"guides/index-tuning/#adding-an-index-after-creation","title":"Adding an Index After Creation","text":"<pre><code>params = Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE)\ncol.create_index(\"embedding\", params, concurrency: 4)\n</code></pre>"},{"location":"guides/index-tuning/#dropping-an-index","title":"Dropping an Index","text":"<pre><code>col.drop_index(\"embedding\")\n</code></pre>"},{"location":"guides/index-tuning/#optimizing","title":"Optimizing","text":"<p>Compact and rebuild indexes for better performance:</p> <pre><code>col.optimize(concurrency: 4)\n</code></pre>"},{"location":"guides/index-tuning/#choosing-an-index-type","title":"Choosing an Index Type","text":"Factor HNSW IVF Flat Dataset size Small to large Medium to large Small Memory usage High Medium Low Build time Medium High None Query speed Fast Fast Slow (linear) Recall Very high High Perfect Best for General use Large, memory-constrained &lt; 10K vectors, exact results"},{"location":"guides/schemas-and-fields/","title":"Schemas and Fields","text":"<p>Every zvec collection is defined by a schema that declares its fields, data types, and indexes.</p>"},{"location":"guides/schemas-and-fields/#creating-a-field","title":"Creating a Field","text":"<p>Use <code>Zvec::FieldSchema.create</code> to define a field:</p> <pre><code>field = Zvec::FieldSchema.create(name, data_type, dimension: 0, nullable: false, index_params: nil)\n</code></pre> Parameter Type Description <code>name</code> String Field name (must be unique within the schema) <code>data_type</code> <code>Zvec::DataType</code> The type of data stored in this field <code>dimension</code> Integer Vector dimensionality (required for vector fields, ignored for scalars) <code>nullable</code> Boolean Whether the field can contain <code>nil</code> values (default: <code>false</code>) <code>index_params</code> IndexParams Index configuration (required for vector fields)"},{"location":"guides/schemas-and-fields/#scalar-data-types","title":"Scalar Data Types","text":"Constant Ruby Type Description <code>DataType::STRING</code> String UTF-8 text <code>DataType::BINARY</code> String Raw binary data <code>DataType::BOOL</code> Boolean <code>true</code> or <code>false</code> <code>DataType::INT32</code> Integer 32-bit signed integer <code>DataType::INT64</code> Integer 64-bit signed integer <code>DataType::UINT32</code> Integer 32-bit unsigned integer <code>DataType::UINT64</code> Integer 64-bit unsigned integer <code>DataType::FLOAT</code> Float 32-bit floating point <code>DataType::DOUBLE</code> Float 64-bit floating point"},{"location":"guides/schemas-and-fields/#dense-vector-types","title":"Dense Vector Types","text":"<p>Dense vectors are stored as fixed-length arrays. You must specify a <code>dimension</code> and <code>index_params</code> when creating a vector field.</p> Constant Element Type Use Case <code>DataType::VECTOR_FP32</code> 32-bit float General purpose (most common) <code>DataType::VECTOR_FP64</code> 64-bit float Higher precision <code>DataType::VECTOR_FP16</code> 16-bit float Memory-efficient storage <code>DataType::VECTOR_INT8</code> 8-bit integer Quantized embeddings <code>DataType::VECTOR_INT16</code> 16-bit integer Quantized embeddings <code>DataType::VECTOR_INT4</code> 4-bit integer (packed as int8) Highly compressed <code>DataType::VECTOR_BINARY32</code> 32-bit unsigned Binary hash vectors <code>DataType::VECTOR_BINARY64</code> 64-bit unsigned Binary hash vectors <pre><code># 384-dimensional FP32 vector with HNSW cosine index\nembedding = Zvec::FieldSchema.create(\"embedding\", Zvec::DataType::VECTOR_FP32,\n              dimension:    384,\n              index_params: Zvec::HnswIndexParams.new(Zvec::MetricType::COSINE))\n</code></pre>"},{"location":"guides/schemas-and-fields/#sparse-vector-types","title":"Sparse Vector Types","text":"<p>Sparse vectors are represented as Ruby hashes mapping integer indices to float values.</p> Constant Value Type <code>DataType::SPARSE_VECTOR_FP32</code> 32-bit float <code>DataType::SPARSE_VECTOR_FP16</code> 16-bit float <pre><code># Set a sparse vector on a Doc\ndoc.set_field(\"sparse_emb\", Zvec::DataType::SPARSE_VECTOR_FP32,\n              { 42 =&gt; 0.8, 99 =&gt; 0.3, 1024 =&gt; 0.1 })\n</code></pre>"},{"location":"guides/schemas-and-fields/#array-types","title":"Array Types","text":"<p>Array fields store variable-length lists of scalar values.</p> Constant Element Type <code>DataType::ARRAY_STRING</code> String <code>DataType::ARRAY_BINARY</code> String <code>DataType::ARRAY_BOOL</code> Boolean <code>DataType::ARRAY_INT32</code> Integer <code>DataType::ARRAY_INT64</code> Integer <code>DataType::ARRAY_UINT32</code> Integer <code>DataType::ARRAY_UINT64</code> Integer <code>DataType::ARRAY_FLOAT</code> Float <code>DataType::ARRAY_DOUBLE</code> Float <pre><code>tags_field = Zvec::FieldSchema.create(\"tags\", Zvec::DataType::ARRAY_STRING)\n</code></pre>"},{"location":"guides/schemas-and-fields/#nullable-fields","title":"Nullable Fields","text":"<p>By default, all fields are non-nullable. Set <code>nullable: true</code> to allow <code>nil</code> values:</p> <pre><code>bio = Zvec::FieldSchema.create(\"bio\", Zvec::DataType::STRING, nullable: true)\n</code></pre> <p>Setting a nullable field to <code>nil</code>:</p> <pre><code>doc.set_field(\"bio\", Zvec::DataType::STRING, nil)\n</code></pre>"},{"location":"guides/schemas-and-fields/#collection-schema","title":"Collection Schema","text":"<p>A <code>CollectionSchema</code> groups fields together. The first STRING field is typically used as the primary key.</p> <pre><code>schema = Zvec::CollectionSchema.create(\"my_collection\", [pk, title, year, embedding])\n</code></pre>"},{"location":"guides/schemas-and-fields/#schema-inspection","title":"Schema Inspection","text":"<pre><code>schema.name                    # =&gt; \"my_collection\"\nschema.all_field_names         # =&gt; [\"pk\", \"title\", \"year\", \"embedding\"]\nschema.has_field?(\"title\")     # =&gt; true\nschema.fields                  # =&gt; [FieldSchema, FieldSchema, ...]\nschema.vector_fields           # =&gt; [FieldSchema] (only vector fields)\nschema.forward_fields          # =&gt; [FieldSchema] (non-vector fields)\nschema.get_field(\"embedding\")  # =&gt; FieldSchema or nil\n</code></pre>"},{"location":"guides/schemas-and-fields/#field-inspection","title":"Field Inspection","text":"<pre><code>field = schema.get_field(\"embedding\")\nfield.name           # =&gt; \"embedding\"\nfield.data_type      # =&gt; VECTOR_FP32\nfield.dimension      # =&gt; 384\nfield.nullable?      # =&gt; false\nfield.vector_field?  # =&gt; true\nfield.dense_vector?  # =&gt; true\nfield.sparse_vector? # =&gt; false\nfield.array_type?    # =&gt; false\nfield.index_type     # =&gt; HNSW\nfield.index_params   # =&gt; HnswIndexParams\n</code></pre>"},{"location":"guides/vector-search/","title":"Vector Search","text":"<p>Vector search finds the most similar documents to a query vector using approximate nearest neighbor (ANN) algorithms.</p>"},{"location":"guides/vector-search/#convenience-method-query_vector","title":"Convenience Method: query_vector","text":"<p>The simplest way to search:</p> <pre><code>results = col.query_vector(\"embedding\", query_vec, top_k: 5)\n</code></pre> <p>Full signature:</p> <pre><code>col.query_vector(\n  field_name,          # name of the vector field to search\n  vector,              # query vector (Array of floats)\n  top_k:,              # number of results to return\n  filter: nil,         # optional scalar filter expression\n  include_vector: false,  # include vector data in results\n  query_params: nil,   # optional QueryParams for tuning\n  output_fields: nil   # optional array of field names to return\n)\n</code></pre>"},{"location":"guides/vector-search/#distance-metrics","title":"Distance Metrics","text":"<p>The distance metric is set when you define the vector field's index:</p> Metric Constant Score Meaning Cosine <code>MetricType::COSINE</code> 0 = identical, 2 = opposite L2 (Euclidean) <code>MetricType::L2</code> 0 = identical, increases with distance Inner Product <code>MetricType::IP</code> Higher = more similar (negated internally) <p>Converting Cosine Distance to Similarity</p> <p>Zvec returns cosine distance (lower is better). To get a similarity score where higher is better: <pre><code>similarity = 1.0 - doc.score\n</code></pre></p>"},{"location":"guides/vector-search/#reading-results","title":"Reading Results","text":"<p>Query results are returned as an array of <code>Doc</code> objects, sorted by distance (closest first):</p> <pre><code>results = col.query_vector(\"embedding\", query_vec, top_k: 3)\n\nresults.each do |doc|\n  h = doc.to_h(col.schema)\n  puts \"#{h['pk']}: #{h['title']} (distance: #{h['score'].round(4)})\"\nend\n</code></pre>"},{"location":"guides/vector-search/#advanced-vectorquery","title":"Advanced: VectorQuery","text":"<p>For full control, build a <code>VectorQuery</code> directly:</p> <pre><code>vq = Zvec::VectorQuery.new\nvq.topk = 10\nvq.field_name = \"embedding\"\nvq.filter = \"year &gt; 2020\"\nvq.include_vector = true\nvq.query_params = Zvec::HnswQueryParams.new(ef: 500)\nvq.output_fields = [\"title\", \"year\"]\n\n# Set the query vector using the field schema for type dispatch\nfield_schema = col.schema.get_field(\"embedding\")\nvq.set_vector(field_schema, query_vec)\n\nresults = col.query(vq)\n</code></pre>"},{"location":"guides/vector-search/#vectorquery-properties","title":"VectorQuery Properties","text":"Property Type Description <code>topk</code> Integer Number of results to return <code>field_name</code> String Vector field to search <code>filter</code> String Scalar filter expression <code>include_vector</code> Boolean Include vector data in results <code>include_doc_id</code> Boolean Include internal doc IDs <code>query_params</code> QueryParams Index-specific search parameters <code>output_fields</code> Array Specific fields to include in results"},{"location":"guides/vector-search/#group-by-query","title":"Group-By Query","text":"<p>Group results by a scalar field value:</p> <pre><code>gq = Zvec::GroupByVectorQuery.new\ngq.field_name = \"embedding\"\ngq.group_by_field_name = \"category\"\ngq.group_count = 5       # number of groups\ngq.group_topk = 3        # results per group\n\nfield_schema = col.schema.get_field(\"embedding\")\ngq.set_vector(field_schema, query_vec)\n\ngroups = col.group_by_query(gq)\ngroups.each do |group|\n  puts \"Group: #{group.group_by_value}\"\n  group.docs.each do |doc|\n    h = doc.to_h(col.schema)\n    puts \"  #{h['title']}\"\n  end\nend\n</code></pre>"},{"location":"guides/vector-search/#output-fields","title":"Output Fields","text":"<p>By default, all scalar fields are returned. Use <code>output_fields</code> to limit the response:</p> <pre><code>results = col.query_vector(\"embedding\", query_vec,\n            top_k: 5,\n            output_fields: [\"title\", \"year\"])\n</code></pre>"},{"location":"guides/vector-search/#including-vectors","title":"Including Vectors","text":"<p>Vector data is excluded from results by default for performance. Set <code>include_vector: true</code> to get vectors back:</p> <pre><code>results = col.query_vector(\"embedding\", query_vec,\n            top_k: 5,\n            include_vector: true)\n\nresults.each do |doc|\n  h = doc.to_h(col.schema)\n  puts h['embedding'].first(5).inspect  # first 5 dimensions\nend\n</code></pre>"}]}